<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artist Toolbox</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.min.js"></script>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: sans-serif;
            background: #f3f4f6; /* Light background for the body */
            /* The container will now fill the body, so flex centering is not needed */
            min-height: 100vh;
            padding: 0; /* Use all available space for the main container */
            box-sizing: border-box;
            color: #1f2937; /* Dark text color for light theme */
        }
        .container {
            /* Main application wrapper */
            width: 100%;
            background-color: #ffffff; /* White background for main container */
            border-radius: 0.8rem; /* Subtle rounding */
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); /* Light shadow for contrast */
            padding: 1.5rem; /* Reduced padding */
            display: flex;
            flex-direction: column; /* Mobile-first: stack panels vertically */
            gap: 1rem; /* Reduced gap */
            transition: all 0.3s ease-in-out;
            height: 100vh; /* Make container fill the entire viewport height */
        }

        /* Desktop layout: Switch to a row-based layout for wider screens */
        @media (min-width: 1024px) {
            .container {
                flex-direction: row;
                gap: 1rem;
            }
            .left-panel {
                flex: 0 0 350px; /* More compact fixed width for left panel */
                padding: 1rem; /* Adjusted padding */
                background-color: #f9fafb; /* Slightly off-white for side panels */
                border-radius: 0.6rem; /* Subtle rounding */
                box-shadow: none; /* No inner shadow, rely on borders */
                height: 100%; /* Make left panel fill height of container */
                overflow-y: auto; /* Allow left panel to scroll if content overflows */
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            .main-content-area {
                flex: 1; /* Main content area grows to fill remaining horizontal space */
                display: flex; /* Corrected: Must be flex to contain tabs */
                flex-direction: column;
                height: 100%; /* Make main content area fill height of container */
            }
            /* On desktop, make the PBR tab a row to create the 3-column layout */
            #texture-pbr-tab.active {
                flex-direction: row; /* Arrange children (canvas, controls) in a row */
                height: 100%; /* Make the tab fill the height of its parent (main-content-area) */
                gap: 1rem; /* Add space between the middle and right columns */
            }
        /* End of desktop layout styles */
        h1 {
            font-size: 1.8rem; /* Smaller h1 */
            color: #111827;
            font-weight: 700;
        }
        h2 {
            font-size: 1.2rem; /* Smaller h2 */
            color: #111827;
            font-weight: 600;
        }
        h3 {
            font-size: 1rem; /* Smaller h3 */
            color: #111827;
            font-weight: 500;
        }
        p, span, label {
            color: #4b5563; /* Mid-grey for general text */
            font-size: 0.85rem; /* Smaller base font size */
        }

        .canvas-container {
            /* General styling for containers holding a canvas preview */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem; /* Very small gap */
            background-color: #f9fafb; /* Light background for canvas containers */
            border-radius: 0.7rem;
            padding: 0.8rem; /* Reduced padding */
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1); /* Subtle light shadow */
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
            cursor: pointer; /* Indicate that map previews are clickable */
            border: 1px solid #e5e7eb; /* Subtle border */
        }
        .canvas-container:hover {
            transform: translateY(-1px); /* Very subtle lift */
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .canvas-wrapper {
            /* A wrapper directly around the canvas element for consistent background and border */
            background-color: #e5e7eb; /* Light grey for canvas wrapper */
            border: 1px solid #d1d5db; /* Lighter border */
            border-radius: 0.5rem;
            padding: 0.3rem; /* Very reduced padding */
            box-shadow: inset 0 2px 4px 0 rgb(0 0 0 / 0.05); /* Subtle inner shadow */
            overflow: hidden;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            border-radius: 0.3rem; /* Very subtle rounding */
            max-width: 100%;
            height: auto;
            display: block;
        }
        input[type="file"] {
            display: none;
        }
        .custom-file-upload {
            /* Styling for the custom "Upload Image" button */
            display: inline-block;
            padding: 0.6rem 1.2rem; /* Much more compact padding */
            cursor: pointer;
            background-color: #3b82f6;
            color: white;
            border-radius: 0.5rem; /* Smaller radius */
            transition: all 0.1s ease, transform 0.05s ease; /* Faster transitions */
            font-weight: 500;
            letter-spacing: 0.01em; /* Tighter letter spacing */
            box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); /* Lighter shadow */
            text-transform: uppercase;
            text-align: center;
            font-size: 0.8rem; /* Smaller font size */
        }
        .custom-file-upload:hover {
            background-color: #2563eb;
            transform: translateY(-0.5px); /* Very subtle lift */
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
        }
        .custom-file-upload:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(59, 130, 246, 0.2);
        }

        /* Loading Spinner */
        .loader {
            border: 2px solid #e5e7eb; /* Thinner, lighter spinner border */
            border-top: 2px solid #4f46e5; /* Accent color */
            width: 24px; /* Smaller */
            height: 24px;
            animation: spin 1s linear infinite;
            display: none;
            margin-top: 0.5rem; /* Reduced margin */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* 3D Canvas Specific Styling */
        #threeJsCanvas {
            background-color: #f3f4f6;
            cursor: grab;
            /* Added to make the canvas fill its wrapper */
            width: 100%;
            height: 100%;
            display: block; /* Ensures proper block-level sizing */
        }
        #threeJsCanvas:active {
            cursor: grabbing;
        }
        
        /* Responsive grid for 2D maps */
        .map-grid {
            /* A grid layout for the small 2D map previews in the left panel */
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(90px, 1fr)); /* Even more compact: 90px min */
            gap: 0.4rem; /* Reduced gap */
            margin-top: 0.8rem; /* Space from controls above */
            padding-top: 0.8rem;
            border-top: 1px solid #e5e7eb; /* Lighter border */
        }
        .map-grid .canvas-container {
            padding: 0.4rem; /* Smaller padding for maps */
            gap: 0.2rem; /* Even smaller gap inside map container */
            border-color: #d1d5db; /* Lighter border for map containers */
        }
        .map-grid .canvas-wrapper {
            width: 90px; /* Fixed small size for previews */
            height: 90px;
            padding: 0.2rem; /* Minimal padding */
            border-color: #d1d5db; /* Lighter border */
        }
        .map-grid canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .map-grid h2 {
            font-size: 0.8rem; /* Smaller font for map titles */
            font-weight: 500;
            color: #374151; /* Darker text */
        }
        .map-grid .flex.items-center.gap-2.mt-2 {
            margin-top: 0.1rem; /* Further reduce margin for checkboxes */
        }
        .map-grid label.text-sm {
            font-size: 0.7rem; /* Smaller font for checkbox labels */
            color: #6b7280; /* Subtler text */
        }
        .map-grid .canvas-container.isolated-view {
            border-color: #7c3aed;
            box-shadow: 0 0 8px rgba(124, 58, 237, 0.5);
        }

        /* Controls Styling (Export and Texture Levels) */
        .controls-group {
            /* A container for a group of related controls (e.g., sliders, buttons) */
            display: flex;
            flex-direction: column;
            gap: 0.5rem; /* Smaller gap */
            width: 100%;
            padding-top: 0.8rem; /* Reduced padding */
            border-top: 1px solid #e5e7eb; /* Lighter border */
            margin-top: 0.8rem;
        }
        .controls-group:first-child {
            border-top: none;
            padding-top: 0;
            margin-top: 0;
        }
        .controls-group select, .controls-group input[type="range"] {
            /* General styling for select dropdowns and range sliders */
            width: 100%;
            padding: 0.4rem 0.6rem; /* Much more compact padding */
            border-radius: 0.4rem; /* Smaller radius */
            border: 1px solid #d1d5db; /* Lighter border */
            background-color: #f9fafb; /* Light input background */
            font-size: 0.8rem; /* Smaller font */
            color: #111827; /* Dark text */
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%236b7280'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'%3E%3C/path%3E%3C/svg%3E"); /* Darker arrow */
            background-repeat: no-repeat;
            background-position: right 0.4rem center; /* Adjusted position */
            background-size: 1em; /* Smaller arrow */
            cursor: pointer;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05); /* Subtle inner shadow */
        }
        .controls-group select:focus, .controls-group input[type="range"]:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 1px rgba(79, 70, 229, 0.4); /* Thinner focus glow */
        }
        /* Specific slider styling */
        .slider-group {
            /* A container for a label and its associated range slider */
            display: flex;
            flex-direction: column;
            gap: 0.2rem; /* Very small gap */
        }
        .slider-group label {
            font-size: 0.75rem; /* Smaller font for slider labels */
            font-weight: 400;
            color: #6b7280; /* Subtler grey for slider labels */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .reset-slider-button {
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            font-size: 1rem;
            padding: 0 0.2rem;
            line-height: 1;
            transition: color 0.1s ease, transform 0.1s ease;
        }
        .reset-slider-button:hover {
            color: #1f2937;
            transform: rotate(90deg);
        }
        .slider-group input[type="range"] {
            height: 3px; /* Even thinner track */
            background: #e5e7eb; /* Lighter track */
            border-radius: 1.5px;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            width: 12px; /* Smaller thumb */
            height: 12px;
            background: #4f46e5;
            box-shadow: 0 1px 2px rgba(79, 70, 229, 0.4);
        }
        .slider-group input[type="range"]::-webkit-slider-thumb:hover {
            background: #4338ca;
            transform: scale(1.02); /* Very subtle hover effect */
        }
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #4f46e5;
            box-shadow: 0 1px 2px rgba(79, 70, 229, 0.4);
        }

        /* Tab Navigation */
        .tab-buttons {
            /* The container for all the main tab buttons (PBR, Colors, etc.) */
            display: flex;
            gap: 0.4rem; /* Very reduced gap */
            margin-bottom: 0.8rem; /* Reduced margin */
            padding-top: 0.6rem;
            border-top: 1px solid #e5e7eb; /* Lighter border */
            justify-content: center;
            width: 100%;
            flex-wrap: wrap;
        }
        .tab-button {
            /* Individual tab button styling */
            padding: 0.4rem 0.8rem; /* Very compact padding */
            border-radius: 0.4rem; /* Smaller radius */
            font-weight: 500;
            font-size: 0.8rem; /* Smaller font */
            cursor: pointer;
            background-color: #f3f4f6; /* Light grey for inactive tabs */
            color: #4b5563; /* Darker grey text */
            transition: all 0.1s ease; /* Faster transition */
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05); /* Subtle inner shadow */
            white-space: nowrap;
        }
        .tab-button:hover {
            background-color: #e5e7eb; /* Slightly darker on hover */
            color: #1f2937; /* Darker text */
            transform: translateY(-0.5px);
        }
        .tab-button.active {
            /* Styling for the currently active tab button */
            background: linear-gradient(45deg, #4f46e5, #7c3aed);
            color: white;
            box-shadow: 0 4px 6px -1px rgba(79, 70, 229, 0.2), 0 2px 4px -2px rgba(79, 70, 229, 0.2);
            transform: translateY(-0.5px);
        }
        .tab-content {
            display: none;
            width: 100%;
        }
        .tab-content.active {
            /* The container for the content of the currently active tab */
            display: flex;
            flex-direction: column;
            gap: 1rem; /* Reduced gap */
        }

        /* Custom layout for tabs that need a full-height canvas area */
        #color-extractor-tab.active,
        #animation-combiner-tab.active,
        #image-to-mesh-tab.active
        {
            height: 100%; /* Make the tab fill the vertical space */
        }
        #color-extractor-tab > .canvas-wrapper:first-child {
            flex-grow: 1; /* Allow the top canvas container to grow and fill space */
            min-height: 0; /* Prevent overflow issues in flex children */
        }
        #color-extractor-tab > .canvas-container:last-child {
            flex-shrink: 0; /* Prevent the palette container from shrinking */
        }
        /* Make the wrapper for the preview canvas grow to fill the available space */
        #color-extractor-tab .canvas-wrapper {
            flex-grow: 1;
            min-height: 0; /* Important for flex-grow in a column */
        }

        /* Color Palette Extractor Specific Styling */
        #colorExtractorCanvas, #stylizeCanvas, #pixelateCanvas { /* Unified styling */
            border: 1px solid #e5e7eb;
            background-color: #f3f4f6;
            border-radius: 0.7rem;
            /* Do not use flex-grow on the canvas itself. Instead, make it fill its parent. */
            width: 100%;
            height: 100%;
        }
        .color-palette {
            /* Container for the extracted color swatches */
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem; /* Reduced gap */
            justify-content: center;
            padding: 0.8rem; /* Consistent with canvas-container */
            background-color: #f9fafb; /* Consistent with canvas-container */
            border-radius: 0.6rem;
            border: 1px solid #e5e7eb; /* Consistent with canvas-container */
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1); /* Consistent with canvas-container */
        }
        .color-swatch {
            /* Individual color swatch styling */
            width: 120px; /* Larger swatches */
            height: 120px;
            border-radius: 0.5rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem; /* Larger font for readability */
            font-weight: 500;
            color: #e0e0e0; /* Light text for contrast on dark colors */
            text-shadow: 0 0 2px rgba(0,0,0,0.7); /* Stronger shadow for readability */
            border: 1px solid rgba(0,0,0,0.1); /* Slightly more visible dark border */
            transition: transform 0.1s ease, border-color 0.1s ease;
        }
        .color-swatch:hover {
            transform: scale(1.05); /* Slightly more pronounced hover */
            border-color: #4f46e5;
        }

        /* Large Hover Preview Canvas Styling - REMOVED */

        /* New container for controls on the right side */
        .right-side-controls-container {
            /* This container holds all the sliders and controls within the PBR tab's right column */
            display: flex;
            flex-direction: column;
            gap: 1rem; /* Standard gap for sections */
            width: 100%;
        }
        @media (min-width: 768px) {
            /* On medium screens and up, make the controls within the right panel responsive */
            .right-side-controls-container {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: space-around;
            }
            .right-side-controls-container > .controls-group {
                flex: 1 1 calc(30% - 0.6rem); /* Roughly 3 items per row, accounting for gap and tighter layout */
                min-width: 280px;
                padding-top: 1rem;
                margin-top: 0;
                border-top: none;
            }
            /* Add top border back for groups that start on a new row */
            .right-side-controls-container > .controls-group:nth-child(3n+1) {
                border-top: none;
                padding-top: 0;
            }
            .right-side-controls-container > .controls-group:nth-child(n+4) {
                border-top: 1px solid #e5e7eb;
                padding-top: 0.8rem;
            }
        }
         /* Minor responsive adjustments for smaller screen sizes */
         /* Adjust for smaller mobile views within panels */
        .left-panel .flex.flex-col.items-center.gap-4 {
            gap: 0.6rem; /* Smaller gap for upload section */
        }
        .left-panel .flex.items-center.gap-2 {
            margin-top: 0.6rem; /* Smaller top margin for checkbox */
        }
        .main-content-area .text-5xl {
            font-size: 2.2rem; /* Even smaller main title on smaller screens */
            line-height: 1.1;
            font-weight: 800;
        }
        .main-content-area .text-lg {
            font-size: 0.9rem; /* Smaller intro text on smaller screens */
            line-height: 1.3;
            color: #6b7280;
        }
        .main-content-area p {
             font-size: 0.9rem; /* Ensure consistent small paragraph text */
        }
        .drop-zone {
            display: block; /* To make the label a block element */
            padding: 1rem;
            border: 2px dashed #d1d5db;
            border-radius: 0.6rem;
            text-align: center;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            background-color: #f9fafb;
            cursor: pointer;
        }
        .drop-zone:hover {
            border-color: #6d28d9;
        }
        .drop-zone.drag-over {
            background-color: #f3f4f6;
            border-color: #4f46e5;
            border-style: solid;
        }
        #mapTooltip {
            position: fixed;
            background-color: rgba(255, 255, 255, 0.85);
            color: #1f2937;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            pointer-events: none; /* So it doesn't interfere with mouse events on other elements */
            z-index: 1001; /* Make sure it's on top of everything */
            max-width: 250px;
            border: 1px solid #e5e7eb;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            transition: opacity 0.1s ease-in-out;
        }
        .reset-camera-button {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid #d1d5db;
            color: #374151;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }
        .reset-camera-button:hover {
            background-color: rgba(79, 70, 229, 0.9);
            border-color: #4f46e5;
            color: white;
            transform: rotate(90deg);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel: Controls and 2D Maps -->
        <div class="left-panel">
            <h1 class="text-center mb-1 tracking-tight">
                Artist Toolbox
            </h1>
            <p class="text-center text-sm leading-relaxed mb-3">
                Your ultimate companion for 2D/3D art workflows.
            </ </p>

            <!-- Main Tab Buttons -->
            <div class="tab-buttons">
                <button class="tab-button active" data-tab-id="texture-pbr-tab">PBR</button>
                <button class="tab-button" data-tab-id="color-extractor-tab">Extract Theme</button>
                <button class="tab-button" data-tab-id="pixelate-tab">Pixelate</button>
                <button class="tab-button" data-tab-id="animation-combiner-tab">Animate</button>
                <button class="tab-button" data-tab-id="image-to-mesh-tab">Image to Mesh</button>
            </div>

            <!-- Controls for Texture Weaver (PBR) Tab -->
            <div id="texture-pbr-controls" class="controls-group active-controls">
                <label id="textureDropZone" class="drop-zone">
                    <span class="text-sm text-gray-400 pointer-events-none">Drag & drop image or click to upload</span>
                    <input type="file" id="textureInput" accept="image/*">
                    <span id="fileNameDisplay" class="text-xs text-center break-words w-full mt-2 block">No image selected.</span>
                    <div id="loadingSpinner" class="loader mx-auto"></div>
                </label>

                <div class="w-full mt-2">
                    <button id="makeSeamlessButton" class="w-full py-1.5 bg-indigo-700 text-white text-xs rounded hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-indigo-500 transition-colors">Make Texture Seamless</button>
                </div>

                <div class="controls-group" id="seamlessControls">
                    <label for="seamlessMethodSelect" class="text-xs">Method:</label>
                    <select id="seamlessMethodSelect">
                        <option value="mirror">Mirror (9-Slice)</option>
                        <option value="blend" selected>Blend (Scattered Edges)</option>
                    </select>

                    <div id="seamlessBlendControls" style="display: block;">
                        <div class="slider-group">
                            <label for="seamlessRadiusSlider">Radius: <span id="seamlessRadiusValue">5</span></label>
                            <input type="range" id="seamlessRadiusSlider" min="1" max="20" step="1" value="5">
                        </div>
                        <div class="slider-group mt-2">
                            <label for="seamlessIntensitySlider">Intensity: <span id="seamlessIntensityValue">100</span></label>
                            <input type="range" id="seamlessIntensitySlider" min="0" max="100" step="1" value="100">
                        </div>
                    </div>
                </div>
                
                <div class="flex items-center gap-1 mt-2">
                    <input type="checkbox" id="invertNormalY" class="h-3.5 w-3.5 text-indigo-600 focus:ring-indigo-500 border-gray-500 rounded cursor-pointer bg-gray-700">
                    <label for="invertNormalY" class="cursor-pointer select-none text-xs">Invert Normal Map Y</label>
                </div>
                <div class="flex items-center gap-1 mt-1">
                    <input type="checkbox" id="invertMetallic" class="h-3.5 w-3.5 text-indigo-600 focus:ring-indigo-500 border-gray-500 rounded cursor-pointer bg-gray-700">
                    <label for="invertMetallic" class="cursor-pointer select-none text-xs">Invert Metallic Map</label>
                </div>

                <!-- 2D Maps Grid for PBR Tab -->
                <div class="map-grid">
                    <div class="canvas-container" data-map-type="Original Texture" data-source-canvas-id="originalTextureCanvas" data-explanation="The base color map (Albedo) that defines the diffuse color of the surface.">
                        <h2 class="text-xs">Original</h2>
                        <div class="flex items-center gap-1 mt-1">
                            <input type="checkbox" id="exportOriginalTexture" class="h-3 w-3 text-indigo-600 focus:ring-indigo-500 border-gray-500 rounded bg-gray-700" checked>
                            <label for="exportOriginalTexture" class="text-xs">Export</label>
                        </div>
                        <div class="canvas-wrapper">
                            <canvas id="originalTextureCanvas" width="90" height="90"></canvas>
                        </div>
                    </div>
                    <div class="canvas-container" data-map-type="Normal Map" data-source-canvas-id="normalMapCanvas" data-explanation="Simulates surface detail and bumps without adding more geometry. Encodes direction vectors in RGB.">
                        <h2 class="text-xs">Normal</h2>
                        <div class="flex items-center gap-1 mt-1">
                            <input type="checkbox" id="exportNormalMap" class="h-3 w-3 text-indigo-600 focus:ring-indigo-500 border-gray-500 rounded bg-gray-700" checked>
                            <label for="exportNormalMap" class="text-xs">Export</label>
                        </div>
                        <div class="canvas-wrapper">
                            <canvas id="normalMapCanvas" width="90" height="90"></canvas>
                        </div>
                    </div>
                    <div class="canvas-container" data-map-type="Roughness Map" data-source-canvas-id="roughnessMapCanvas" data-explanation="Controls how rough or smooth a surface is. Black (0) is smooth (shiny), White (1) is rough (matte).">
                        <h2 class="text-xs">Roughness</h2>
                        <div class="flex items-center gap-1 mt-1">
                            <input type="checkbox" id="exportRoughnessMap" class="h-3 w-3 text-indigo-600 focus:ring-indigo-500 border-gray-500 rounded bg-gray-700" checked>
                            <label for="exportRoughnessMap" class="text-xs">Export</label>
                        </div>
                        <div class="canvas-wrapper">
                            <canvas id="roughnessMapCanvas" width="90" height="90"></canvas>
                        </div>
                    </div>
                    <div class="canvas-container" data-map-type="Ambient Occlusion Map" data-source-canvas-id="aoMapCanvas" data-explanation="Simulates contact shadows in crevices and corners, adding depth. White means fully lit, Black means fully occluded.">
                        <h2 class="text-xs">AO</h2>
                        <div class="flex items-center gap-1 mt-1">
                            <input type="checkbox" id="exportAOMap" class="h-3 w-3 text-indigo-600 focus:ring-indigo-500 border-gray-500 rounded bg-gray-700" checked>
                            <label for="exportAOMap" class="text-xs">Export</label>
                        </div>
                        <div class="canvas-wrapper">
                            <canvas id="aoMapCanvas" width="90" height="90"></canvas>
                        </div>
                    </div>
                    <div class="canvas-container" data-map-type="Metallic Map" data-source-canvas-id="metallicMapCanvas" data-explanation="Defines which parts of the surface are metallic. White (1) is metallic, Black (0) is non-metallic (dielectric).">
                        <h2 class="text-xs">Metallic</h2>
                        <div class="flex items-center gap-1 mt-1">
                            <input type="checkbox" id="exportMetallicMap" class="h-3 w-3 text-indigo-600 focus:ring-indigo-500 border-gray-500 rounded bg-gray-700" checked>
                            <label for="exportMetallicMap" class="text-xs">Export</label>
                        </div>
                        <div class="canvas-wrapper">
                            <canvas id="metallicMapCanvas" width="90" height="90"></canvas>
                        </div>
                    </div>
                    <div class="canvas-container" data-map-type="Displacement Map" data-source-canvas-id="displacementMapCanvas" data-explanation="Actually displaces the geometry vertices to create real height and depth. White is high, Black is low.">
                        <h2 class="text-xs">Displacement</h2>
                        <div class="flex items-center gap-1 mt-1">
                            <input type="checkbox" id="exportDisplacementMap" class="h-3 w-3 text-indigo-600 focus:ring-indigo-500 border-gray-500 rounded bg-gray-700" checked>
                            <label for="exportDisplacementMap" class="text-xs">Export</label>
                        </div>
                        <div class="canvas-wrapper">
                            <canvas id="displacementMapCanvas" width="90" height="90"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Controls for Color Extractor Tab -->
            <div id="color-extractor-controls" class="controls-group" style="display:none;">
                <label id="colorDropZone" class="drop-zone">
                    <span class="text-sm text-gray-400 pointer-events-none">Drag & drop image or click to upload</span>
                    <input type="file" id="colorImageInput" accept="image/*">
                    <span id="colorFileNameDisplay" class="text-xs text-center break-words w-full mt-2 block">No image selected.</span>
                    <div id="colorLoadingSpinner" class="loader mx-auto"></div>
                </label>
                <div class="slider-group mt-3">
                    <label for="numColorsSlider">Colors: <span id="numColorsValue">5</span></label>
                    <input type="range" id="numColorsSlider" min="1" max="10" step="1" value="5">
                </div>
            </div>

            <!-- Controls for Pixelate Tab -->
            <div id="pixelate-controls" class="controls-group" style="display:none;">
                <h3 class="mb-2">Pixelate Mode</h3>
                <p class="text-xs text-gray-500 mb-2">
                    Upload image or use main.
                </p>
                <label id="pixelateDropZone" class="drop-zone">
                    <span class="text-sm text-gray-400 pointer-events-none">Drag & drop image or click to upload</span>
                    <input type="file" id="pixelateImageInput" accept="image/*">
                    <span id="pixelateFileNameDisplay" class="text-xs text-center break-words w-full mt-2 block">No image selected.</span>
                    <div id="pixelateLoadingSpinner" class="loader mx-auto"></div>
                </label>
                <div class="slider-group mt-3">
                    <label for="pixelSizeSlider">Pixel Size: <span id="pixelSizeValue">8px</span></label>
                    <input type="range" id="pixelSizeSlider" min="1" max="50" step="1" value="10">
                </div>
            </div>

            <!-- Controls for Animation Combiner Tab -->
            <div id="animation-combiner-controls" class="controls-group" style="display:none;">
                <h3 class="mb-2">Animation Combiner</h3>
                <p class="text-xs text-gray-500 mb-2">
                    Upload a character and one or more animations.
                </p>
                <div class="flex flex-col items-center gap-4 w-full">
                    <!-- Character Upload -->
                    <div class="w-full">
                        <label for="characterFbxInput" class="custom-file-upload w-full">
                            Upload Character FBX
                        </label>
                        <input type="file" id="characterFbxInput" accept=".fbx">
                        <span id="characterFileNameDisplay" class="text-xs text-center break-words w-full mt-1 block">No character file selected.</span>
                    </div>

                    <!-- Animations Upload -->
                    <div class="w-full">
                        <label for="animationFbxInput" class="custom-file-upload w-full">
                            Upload Animation(s) FBX
                        </label>
                        <input type="file" id="animationFbxInput" accept=".fbx" multiple>
                        <span id="animationFileNameDisplay" class="text-xs text-center break-words w-full mt-1 block">No animation files selected.</span>
                    </div>
                </div>
                <div class="controls-group mt-3">
                    <label for="animationSelect" class="text-xs font-medium">Select Animation:</label>
                    <select id="animationSelect">
                        <option value="">-- Load animations first --</option>
                    </select>
                </div>
                <div class="slider-group">
                    <label for="animationSpeedSlider">Speed: <span id="animationSpeedValue">1.00</span></label>
                    <input type="range" id="animationSpeedSlider" min="0.1" max="2.0" step="0.01" value="1.0">
                </div>
                <div class="flex items-center gap-1 mt-2">
                    <input type="checkbox" id="enableRootMotion" class="h-3.5 w-3.5 text-indigo-600 focus:ring-indigo-500 border-gray-500 rounded cursor-pointer bg-gray-700">
                    <label for="enableRootMotion" class="cursor-pointer select-none text-xs">Enable Root Motion</label>
                </div>
                <button id="loadAndPlayAnimationsButton" class="custom-file-upload mt-2">Load & Play</button>
            </div>

            <!-- Controls for Image to Mesh Tab -->
            <div id="image-to-mesh-controls" class="controls-group" style="display:none;">
                <h3 class="mb-2">Image to Mesh</h3>
                <p class="text-xs text-gray-500 mb-2">
                    Upload an image to convert it into a 3D mesh. Lighter areas will be higher.
                </p>
                <label id="meshDropZone" class="drop-zone">
                    <span class="text-sm text-gray-400 pointer-events-none">Drag & drop image or click to upload</span>
                    <input type="file" id="meshImageInput" accept="image/*">
                    <span id="meshFileNameDisplay" class="text-xs text-center break-words w-full mt-2 block">No image selected.</span>
                    <div id="meshLoadingSpinner" class="loader mx-auto"></div>
                </label>
                <div class="slider-group mt-3">
                    <label for="meshDetailSlider">Detail (Subdivisions): <span id="meshDetailValue">64</span></label>
                    <input type="range" id="meshDetailSlider" min="16" max="512" step="16" value="64">
                </div>
                <div class="slider-group mt-2">
                    <label for="meshHeightSlider">Height Scale: <span id="meshHeightValue">2</span></label>
                    <input type="range" id="meshHeightSlider" min="0" max="200" step="1" value="2">
                </div>
                <div class="flex items-center gap-1 mt-2">
                    <input type="checkbox" id="smoothMeshCheckbox" class="h-3.5 w-3.5 text-indigo-600 focus:ring-indigo-500 border-gray-500 rounded cursor-pointer bg-gray-700" checked>
                    <label for="smoothMeshCheckbox" class="cursor-pointer select-none text-xs">Smooth Mesh</label>
                </div>
                <div class="slider-group mt-2" id="meshSmoothingControls" style="display: flex;">
                    <label for="meshSmoothingIterationsSlider">Smoothing Iterations: <span id="meshSmoothingIterationsValue">2</span></label>
                    <input type="range" id="meshSmoothingIterationsSlider" min="1" max="10" step="1" value="2">
                </div>
                <!-- NEW: Mesh Preview Mode Selector -->
                <div class="controls-group mt-2">
                    <label for="meshPreviewModeSelect" class="text-xs font-medium">Left Preview Mode:</label>
                    <select id="meshPreviewModeSelect">
                        <option value="depth">Depth Map (Black & White)</option>
                        <option value="normal">Normal Map (RGB Colors)</option>
                        <option value="wireframe" selected>Wireframe</option>
                    </select>
                </div>
                <button id="exportGlbButton" class="custom-file-upload mt-2">Export as .GLB</button>
            </div>
        </div>

        <!-- Center Panel: Main Content Area (Tabs for tools) -->
        <div class="main-content-area">
            <!-- Texture PBR Content -->
            <!-- This tab is a flex container. On desktop, it becomes a row to create a 3-column layout. -->
            <div id="texture-pbr-tab" class="tab-content active">
                <!-- Middle Column: 3D Canvas Preview -->
                <div class="canvas-wrapper flex justify-center items-center" style="flex: 1 1 0; min-width: 0; height: 100%; position: relative;">
                    <button id="resetPbrCameraBtn" class="reset-camera-button" title="Reset Camera">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 18px; height: 18px;"><path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.664 0l3.18-3.185m-3.181 9.348a8.25 8.25 0 00-11.664 0l-3.18 3.185m3.181-9.348L2.985 19.644" /></svg>
                    </button>
                    <canvas id="threeJsCanvas" width="600" height="380"></canvas>
                </div>

                <!-- Right Column: PBR Controls -->
                <div class="right-side-controls-container" style="flex: 0 0 320px; height: 100%; overflow-y: auto; background-color: #f9fafb; border-radius: 0.6rem; padding: 1rem;">
                    <div class="controls-group">
                        <h3 class="mb-2">Material & Map Adjustments</h3>
                        
                        <div class="slider-group">
                            <label for="normalStrengthSlider">
                                <span>Normal Strength: <span id="normalStrengthValue">1.00</span></span>
                                <button class="reset-slider-button" data-slider-id="normalStrengthSlider" title="Reset to default">↺</button>
                            </label>
                            <input type="range" id="normalStrengthSlider" min="0.0" max="2.0" step="0.01" value="1.0">
                        </div>

                        <div class="slider-group">
                            <label for="roughnessIntensitySlider">
                                <span>Roughness Intensity: <span id="roughnessIntensityValue">1.00</span></span>
                                <button class="reset-slider-button" data-slider-id="roughnessIntensitySlider" title="Reset to default">↺</button>
                            </label>
                            <input type="range" id="roughnessIntensitySlider" min="0.0" max="2.0" step="0.01" value="1.0">
                        </div>

                        <div class="slider-group">
                            <label for="aoContrastSlider">
                                <span>AO Contrast: <span id="aoContrastValue">1.00</span></span>
                                <button class="reset-slider-button" data-slider-id="aoContrastSlider" title="Reset to default">↺</button>
                            </label>
                            <input type="range" id="aoContrastSlider" min="0.0" max="2.0" step="0.01" value="1.0">
                        </div>
                        <div class="slider-group">
                            <label for="aoIntensitySlider">
                                <span>AO Intensity: <span id="aoIntensityValue">1.00</span></span>
                                <button class="reset-slider-button" data-slider-id="aoIntensitySlider" title="Reset to default">↺</button>
                            </label>
                            <input type="range" id="aoIntensitySlider" min="0.0" max="1.0" step="0.01" value="1.0">
                        </div>

                        <div class="slider-group">
                            <label for="metallicSharpnessSlider">
                                <span>Metallic Sharpness: <span id="metallicSharpnessValue">0.15</span></span>
                                <button class="reset-slider-button" data-slider-id="metallicSharpnessSlider" title="Reset to default">↺</button>
                            </label>
                            <input type="range" id="metallicSharpnessSlider" min="0.0" max="1.0" step="0.01" value="0.15">
                        </div>

                        <div class="slider-group">
                            <label for="displacementDetailSlider">
                                <span>Displacement Detail: <span id="displacementDetailValue">0.30</span></span>
                                <button class="reset-slider-button" data-slider-id="displacementDetailSlider" title="Reset to default">↺</button>
                            </label>
                            <input type="range" id="displacementDetailSlider" min="0.0" max="2.0" step="0.01" value="0.30">
                        </div>
                        <div class="slider-group">
                            <label for="displacementScaleSlider">
                                <span>Displacement Scale: <span id="displacementScaleValue">0.04</span></span>
                                <button class="reset-slider-button" data-slider-id="displacementScaleSlider" title="Reset to default">↺</button>
                            </label>
                            <input type="range" id="displacementScaleSlider" min="0.0" max="1.0" step="0.01" value="0.04">
                        </div>
                        <div class="slider-group">
                            <label for="displacementBiasSlider">
                                <span>Displacement Bias: <span id="displacementBiasValue">-0.02</span></span>
                                <button class="reset-slider-button" data-slider-id="displacementBiasSlider" title="Reset to default">↺</button>
                            </label>
                            <input type="range" id="displacementBiasSlider" min="-0.5" max="0.5" step="0.01" value="-0.02">
                        </div>
                    </div>

                    <div class="controls-group">
                        <h3 class="mb-2">Lighting</h3>
                        <div class="slider-group">
                            <label for="sunAzimuthSlider">
                                <span>Sun Azimuth: <span id="sunAzimuthValue">45</span>°</span>
                                <button class="reset-slider-button" data-slider-id="sunAzimuthSlider" title="Reset to default">↺</button>
                            </label>
                            <input type="range" id="sunAzimuthSlider" min="0" max="360" step="1" value="45">
                        </div>
                        <div class="slider-group">
                            <label for="sunElevationSlider">
                                <span>Sun Elevation: <span id="sunElevationValue">45</span>°</span>
                                <button class="reset-slider-button" data-slider-id="sunElevationSlider" title="Reset to default">↺</button>
                            </label>
                            <input type="range" id="sunElevationSlider" min="0" max="90" step="1" value="45">
                        </div>
                        <div class="slider-group">
                            <label for="sunIntensitySlider">
                                <span>Sun Intensity: <span id="sunIntensityValue">1.00</span></span>
                                <button class="reset-slider-button" data-slider-id="sunIntensitySlider" title="Reset to default">↺</button>
                            </label>
                            <input type="range" id="sunIntensitySlider" min="0" max="5" step="0.01" value="1.0">
                        </div>
                    </div>

                    <div class="controls-group">
                        <h3 class="mb-2">Export Options</h3>
                        <label for="exportResolution" class="text-xs font-medium">
                            <span>Resolution:</span>
                        </label>
                        <select id="exportResolution">
                            <option value="original" selected>Original Size</option>
                            <option value="24">24x24</option>
                            <option value="48">48x48</option>
                            <option value="64">64x64</option>
                            <option value="128">128x128</option>
                            <option value="256">256x256</option>
                            <option value="512">512x512</option>
                            <option value="1024">1024x1024</option>
                        </select>
                        <button id="exportButton" class="custom-file-upload mt-2">Export Selected</button>
                    </div>
                </div>
            </div>

            <!-- Color Extractor Tab Content -->
            <div id="color-extractor-tab" class="tab-content">
                <div class="canvas-wrapper w-full flex justify-center items-center">
                    <canvas id="colorExtractorCanvas" width="600" height="380"></canvas>
                </div>

                <div class="canvas-container">
                    <div id="extractedColorPalette" class="color-palette w-full min-h-[70px]">
                        <!-- Color swatches will be inserted here -->
                        <p class="text-center w-full text-gray-500 text-sm"></p>
                    </div>
                </div>
            </div>

            <!-- Pixelate Tab Content -->
            <div id="pixelate-tab" class="tab-content">
                <h1 class="text-center mb-2 tracking-tight">
                    Pixelate Image
                </h1>
                <p class="text-center text-sm leading-tight max-w-xl mx-auto mb-3">
                    Transform your image into a pixelated artwork by adjusting the pixel size.
                </p>
                <div class="canvas-container">
                    <h2 class="text-base">Pixelated Image Preview</h2>
                    <div class="canvas-wrapper w-full flex justify-center items-center" style="height: 380px; max-height: 50vh;">
                        <canvas id="pixelateCanvas" width="600" height="380"></canvas>
                    </div>
                </div>
            </div>


            <!-- Animation Combiner Tab Content -->
            <div id="animation-combiner-tab" class="tab-content">
                <h1 class="text-center mb-2 tracking-tight">
                    Animation Combiner
                </h1>
                <p class="text-center text-sm leading-tight max-w-xl mx-auto mb-3">
                    (Conceptual Feature) Blend multiple FBX animations for character models.
                </p>

                <div class="canvas-container" style="flex-grow: 1; min-height: 0;">
                    <h2 class="text-base">3D Animation Preview</h2>
                    <div id="animationCanvasWrapper" class="canvas-wrapper w-full flex-grow justify-center items-center">
                        <p id="animationPlaceholderText" class="text-center text-gray-500 text-sm p-4">Upload a character and animation files, then click "Load & Play".</p>
                        <canvas id="animationCombinerThreeJsCanvas" style="display:none; width: 100%; height: 100%;"></canvas>
                    </div>
                </div>
            </div>

            <!-- Image to Mesh Tab Content -->
            <div id="image-to-mesh-tab" class="tab-content">
                <div class="relative">
                    <h1 class="text-center mb-2 tracking-tight">
                        Image to 3D Mesh Converter
                    </h1>
                    <p class="text-center text-sm leading-tight max-w-xl mx-auto mb-3">
                        Generate a 3D mesh from a 2D image's brightness values. Use the controls on the left to adjust the result.
                    </p>
                    <button id="resetMeshCameraBtn" class="reset-camera-button" title="Reset Camera" style="top: 0; right: 0;">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 18px; height: 18px;"><path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.664 0l3.18-3.185m-3.181 9.348a8.25 8.25 0 00-11.664 0l-3.18 3.185m3.181-9.348L2.985 19.644" /></svg>
                    </button>
                </div>

                <div id="mesh-previews-container" class="flex flex-col lg:flex-row gap-4" style="flex-grow: 1; min-height: 0;">
                    <!-- Left Preview: Depth/Geometry -->
                    <div class="canvas-container flex-1" style="min-width: 0;">
                        <h2 class="text-base">Depth Preview (Geometry)</h2>
                        <div id="meshDepthCanvasWrapper" class="canvas-wrapper w-full flex-grow justify-center items-center">
                            <p id="meshDepthPlaceholderText" class="text-center text-gray-500 text-sm p-4">Upload an image to generate a mesh.</p>
                            <canvas id="imageToMeshDepthCanvas" style="display:none; width: 100%; height: 100%;"></canvas>
                        </div>
                    </div>
                    <!-- Right Preview: Textured Mesh -->
                    <div class="canvas-container flex-1" style="min-width: 0;">
                        <h2 class="text-base">Textured Mesh Preview</h2>
                        <div id="meshCanvasWrapper" class="canvas-wrapper w-full flex-grow justify-center items-center">
                            <p id="meshPlaceholderText" class="text-center text-gray-500 text-sm p-4">Upload an image to generate a mesh.</p>
                            <canvas id="imageToMeshThreeJsCanvas" style="display:none; width: 100%; height: 100%;"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tooltip for Map Explanations -->
    <div id="mapTooltip" style="display: none;"></div>

    <!-- Consolidated JavaScript as a single ES Module -->
    <script type="module">
        // --- Import Three.js Addons from Global Scope ---
        const { FBXLoader } = THREE;
        const { OrbitControls } = THREE;
        /**
         * This script handles all the client-side logic for the 3D Artist Toolbox.
         * It includes tab switching, image processing for map generation, 3D rendering with Three.js,
         * and interactive controls for various artistic effects.
         */
        // --- DOM Element References ---
        const textureInput = document.getElementById('textureInput');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const makeSeamlessButton = document.getElementById('makeSeamlessButton');
        const textureDropZone = document.getElementById('textureDropZone');
        const stylizeDropZone = document.getElementById('stylizeDropZone');
        const pixelateDropZone = document.getElementById('pixelateDropZone');
        const meshDropZone = document.getElementById('meshDropZone');
        const seamlessMethodSelect = document.getElementById('seamlessMethodSelect');
        const seamlessBlendControls = document.getElementById('seamlessBlendControls');
        const seamlessRadiusSlider = document.getElementById('seamlessRadiusSlider');
        const seamlessRadiusValue = document.getElementById('seamlessRadiusValue');
        const seamlessIntensitySlider = document.getElementById('seamlessIntensitySlider');
        const seamlessIntensityValue = document.getElementById('seamlessIntensityValue');


        const originalTextureCanvas = document.getElementById('originalTextureCanvas');
        const normalMapCanvas = document.getElementById('normalMapCanvas');
        const roughnessMapCanvas = document.getElementById('roughnessMapCanvas');
        const aoMapCanvas = document.getElementById('aoMapCanvas');
        const metallicMapCanvas = document.getElementById('metallicMapCanvas');
        const displacementMapCanvas = document.getElementById('displacementMapCanvas');
        const invertMetallicCheckbox = document.getElementById('invertMetallic');
        const invertNormalYCheckbox = document.getElementById('invertNormalY');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const mapTooltip = document.getElementById('mapTooltip');
        const threeJsCanvas = document.getElementById('threeJsCanvas');
        
        // Removed large preview canvas elements
        // const largePreviewCanvasContainer = document.getElementById('largePreviewCanvasContainer');
        // const largePreviewCanvas = document.getElementById('largePreviewCanvas');
        // const largePreviewTitle = document.getElementById('largePreviewTitle');
        // const largePreviewCtx = largePreviewCanvas.getContext('2d');


        const exportResolutionSelect = document.getElementById('exportResolution');
        const exportButton = document.getElementById('exportButton');

        const normalStrengthSlider = document.getElementById('normalStrengthSlider');
        const normalStrengthValueSpan = document.getElementById('normalStrengthValue');
        const aoIntensitySlider = document.getElementById('aoIntensitySlider');
        const aoIntensityValueSpan = document.getElementById('aoIntensityValue');
        const displacementScaleSlider = document.getElementById('displacementScaleSlider');
        const displacementScaleValueSpan = document.getElementById('displacementScaleValue');
        const displacementBiasSlider = document.getElementById('displacementBiasSlider');
        const displacementBiasValueSpan = document.getElementById('displacementBiasValue');

        // Export Checkboxes
        const exportOriginalTextureCheckbox = document.getElementById('exportOriginalTexture');
        const exportNormalMapCheckbox = document.getElementById('exportNormalMap');
        const exportRoughnessMapCheckbox = document.getElementById('exportRoughnessMap');
        const exportAOMapCheckbox = document.getElementById('exportAOMap');
        const exportMetallicMapCheckbox = document.getElementById('exportMetallicMap');
        const exportDisplacementMapCheckbox = document.getElementById('exportDisplacementMap');

        // 2D Map Generation Adjustment Sliders
        const roughnessIntensitySlider = document.getElementById('roughnessIntensitySlider');
        const roughnessIntensityValueSpan = document.getElementById('roughnessIntensityValue');
        const aoContrastSlider = document.getElementById('aoContrastSlider');
        const aoContrastValueSpan = document.getElementById('aoContrastValue');
        const metallicSharpnessSlider = document.getElementById('metallicSharpnessSlider');
        const metallicSharpnessValueSpan = document.getElementById('metallicSharpnessValue');
        const displacementDetailSlider = document.getElementById('displacementDetailSlider');
        const displacementDetailValueSpan = document.getElementById('displacementDetailValue');

        // Lighting Controls
        const sunAzimuthSlider = document.getElementById('sunAzimuthSlider');
        const sunAzimuthValue = document.getElementById('sunAzimuthValue');
        const sunElevationSlider = document.getElementById('sunElevationSlider');
        const sunElevationValue = document.getElementById('sunElevationValue');
        const sunIntensitySlider = document.getElementById('sunIntensitySlider');
        const sunIntensityValue = document.getElementById('sunIntensityValue');


        // Color Extractor related variables
        const colorImageInput = document.getElementById('colorImageInput');
        const colorFileNameDisplay = document.getElementById('colorFileNameDisplay');
        const colorLoadingSpinner = document.getElementById('colorLoadingSpinner');
        const colorExtractorCanvas = document.getElementById('colorExtractorCanvas');
        const numColorsSlider = document.getElementById('numColorsSlider');
        const numColorsValueSpan = document.getElementById('numColorsValue');

        // Pixelate Mode related variables
        const pixelateImageInput = document.getElementById('pixelateImageInput');
        const pixelateFileNameDisplay = document.getElementById('pixelateFileNameDisplay');
        const pixelateLoadingSpinner = document.getElementById('pixelateLoadingSpinner');
        const pixelSizeSlider = document.getElementById('pixelSizeSlider');
        const pixelSizeValueSpan = document.getElementById('pixelSizeValue');
        const pixelateCanvas = document.getElementById('pixelateCanvas');

        // Animation Combiner related variables
        const characterFbxInput = document.getElementById('characterFbxInput');
        const characterFileNameDisplay = document.getElementById('characterFileNameDisplay');
        const animationFbxInput = document.getElementById('animationFbxInput');
        const animationFileNameDisplay = document.getElementById('animationFileNameDisplay');
        const animationSelect = document.getElementById('animationSelect');
        const animationSpeedSlider = document.getElementById('animationSpeedSlider');
        const animationSpeedValueSpan = document.getElementById('animationSpeedValue');
        const loadAndPlayAnimationsButton = document.getElementById('loadAndPlayAnimationsButton');
        const animationCombinerThreeJsCanvas = document.getElementById('animationCombinerThreeJsCanvas');
        const animationPlaceholderText = document.getElementById('animationPlaceholderText');
        const enableRootMotionCheckbox = document.getElementById('enableRootMotion');

        // Image to Mesh related variables
        const meshImageInput = document.getElementById('meshImageInput');
        const meshFileNameDisplay = document.getElementById('meshFileNameDisplay');
        const meshLoadingSpinner = document.getElementById('meshLoadingSpinner');
        const meshDetailSlider = document.getElementById('meshDetailSlider');
        const meshDetailValue = document.getElementById('meshDetailValue');
        const meshHeightSlider = document.getElementById('meshHeightSlider');
        const meshHeightValue = document.getElementById('meshHeightValue');
        const exportGlbButton = document.getElementById('exportGlbButton');
        const imageToMeshThreeJsCanvas = document.getElementById('imageToMeshThreeJsCanvas');
        const smoothMeshCheckbox = document.getElementById('smoothMeshCheckbox');
        const meshSmoothingControls = document.getElementById('meshSmoothingControls');
        const meshSmoothingIterationsSlider = document.getElementById('meshSmoothingIterationsSlider');
        const meshSmoothingIterationsValue = document.getElementById('meshSmoothingIterationsValue');
        const meshPreviewModeSelect = document.getElementById('meshPreviewModeSelect');
        const meshPlaceholderText = document.getElementById('meshPlaceholderText');
        const imageToMeshDepthCanvas = document.getElementById('imageToMeshDepthCanvas');
        const meshDepthPlaceholderText = document.getElementById('meshDepthPlaceholderText');

        const resetPbrCameraBtn = document.getElementById('resetPbrCameraBtn');
        const resetMeshCameraBtn = document.getElementById('resetMeshCameraBtn');


        // Tab and Control Group elements
        const textureWeaverTab = document.getElementById('texture-pbr-tab');
        const colorExtractorTab = document.getElementById('color-extractor-tab');
        const pixelateTab = document.getElementById('pixelate-tab');
        const animationCombinerTab = document.getElementById('animation-combiner-tab');
        const imageToMeshTab = document.getElementById('image-to-mesh-tab');
        const textureWeaverControls = document.getElementById('texture-pbr-controls');
        const colorExtractorControls = document.getElementById('color-extractor-controls');
        const stylizeControls = document.getElementById('stylize-controls');
        const pixelateControls = document.getElementById('pixelate-controls');
        const animationCombinerControls = document.getElementById('animation-combiner-controls');
        const imageToMeshControls = document.getElementById('image-to-mesh-controls');


        // --- 2D Canvas Contexts ---
        const originalCtx = originalTextureCanvas.getContext('2d');
        const normalCtx = normalMapCanvas.getContext('2d');
        const roughnessCtx = roughnessMapCanvas.getContext('2d');
        const aoCtx = aoMapCanvas.getContext('2d');
        const metallicCtx = metallicMapCanvas.getContext('2d');
        const displacementCtx = displacementMapCanvas.getContext('2d');
        const colorExtractorCtx = colorExtractorCanvas.getContext('2d');
        const pixelateCtx = pixelateCanvas.getContext('2d');

        // --- Full-Resolution Offscreen Canvases for 3D Textures ---
        // These are never added to the DOM. They hold the full-res texture data
        // to prevent the 3D preview from using the small 90x90 UI canvases.
        const fullResOriginalCanvas = document.createElement('canvas');
        const fullResNormalCanvas = document.createElement('canvas');
        const fullResRoughnessCanvas = document.createElement('canvas');
        const fullResAoCanvas = document.createElement('canvas');
        const fullResMetallicCanvas = document.createElement('canvas');
        const fullResDisplacementCanvas = document.createElement('canvas');
        const pristineSourceCanvas = document.createElement('canvas'); // NEW: Stores the original, unmodified uploaded image.

        const fullResNormalCtx = fullResNormalCanvas.getContext('2d');
        const fullResRoughnessCtx = fullResRoughnessCanvas.getContext('2d');
        const fullResAoCtx = fullResAoCanvas.getContext('2d');
        const fullResMetallicCtx = fullResMetallicCanvas.getContext('2d');
        const fullResDisplacementCtx = fullResDisplacementCanvas.getContext('2d');

        // --- Global Variables for Unified Image Handling ---
        let sharedImage = null; // Stores the main image uploaded in Texture Weaver
        let sharedFileName = 'No image selected.';

        let colorExtractorLocalImage = null; // Stores image specifically uploaded for Color Extractor tab
        let pixelateLocalImage = null; // Stores image specifically uploaded for Pixelate tab
        let meshLocalImage = null; // Stores image specifically for Image to Mesh tab

        let currentActiveTabId = 'texture-pbr-tab'; // Keep track of the active tab for specific logic

        const MAP_CANVAS_SIZE = 90; // Standard size for generated 2D maps (for display in left panel)

        const TILE_FACTOR = 5; // How many times the texture should repeat on the ground plane's longest dimension.

        // --- Three.js Variables ---
        let scene, camera, renderer, mesh, planeMesh, textureGroup, textureWeaverMaterial, defaultGroundMaterial, texturedGroundMaterial, sunLight;
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        // --- Animation Combiner Three.js Variables ---
        let animScene, animCamera, animRenderer, animControls, animMixer, loadedCharacter, rootBoneHelper;
        // --- Image to Mesh Three.js Variables ---
        let meshScene, meshCamera, meshRenderer, meshControls, generatedMesh, meshDepthScene, meshDepthCamera, meshDepthRenderer, generatedDepthMesh;
        const animClock = new THREE.Clock();
        // Using a map for actions allows easy lookup by animation name
        const animationActions = new Map();
        let activeAction, previousAction; // The currently playing animation action and the previous one for crossfading
        let isAnimSceneInitialized = false;
        // --- Root Motion State ---
        let isRootMotionFirstFrame = true;
        let isMeshSceneInitialized = false;
        const initialRootBonePosition = new THREE.Vector3();
        const initialRootBoneQuaternion = new THREE.Quaternion();


        // --- Helper Functions ---

        /**
         * Sets up a drag-and-drop zone for file uploads.
         * @param {HTMLElement} dropZoneElement The element to turn into a drop zone.
         * @param {HTMLInputElement} fileInputElement The associated file input.
         */
        function setupDropZone(dropZoneElement, fileInputElement) {
            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZoneElement.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });

            // Highlight drop zone when item is dragged over it
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZoneElement.addEventListener(eventName, () => {
                    dropZoneElement.classList.add('drag-over');
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZoneElement.addEventListener(eventName, () => {
                    dropZoneElement.classList.remove('drag-over');
                }, false);
            });

            // Handle dropped files
            dropZoneElement.addEventListener('drop', (e) => {
                const dt = e.dataTransfer;
                const files = dt.files;

                if (files.length > 0) {
                    fileInputElement.files = files;
                    // Manually trigger the 'change' event on the file input
                    // so our existing loadImageAndSetShared function runs.
                    const changeEvent = new Event('change', { bubbles: true });
                    fileInputElement.dispatchEvent(changeEvent);
                }
            }, false);
        }

        /**
         * Custom message box function to replace alert().
         * Creates a temporary, styled div in the center of the screen.
         * @param {string} message - The message to display.
         * @param {string} type - 'error', 'success', or 'info' for styling.
         */
        function showMessageBox(message, type = 'info') {
            const messageBox = document.createElement('div');
            let bgColor, borderColor, textColor;

            switch (type) {
                case 'error':
                    bgColor = '#3b0000';
                    borderColor = '#8a0000';
                    textColor = '#ff6b6b';
                    break;
                case 'success':
                    bgColor = '#003b00';
                    borderColor = '#008a00';
                    textColor = '#6bff6b';
                    break;
                case 'info':
                default:
                    bgColor = '#002f5e';
                    borderColor = '#0062a3';
                    textColor = '#87ceeb';
                    break;
            }

            messageBox.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background-color: ${bgColor}; border: 1px solid ${borderColor}; padding: 15px 20px;
                border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.4); z-index: 1000;
                font-family: 'Inter', sans-serif; color: ${textColor}; text-align: center;
                max-width: 80%; /* Responsive width */
                box-sizing: border-box;
                font-size: 0.9rem;
            `;
            messageBox.innerHTML = `
                <p>${message}</p>
                <button onclick="this.parentNode.remove()" style="margin-top: 10px; padding: 6px 12px; background-color: ${borderColor}; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500; font-size: 0.8rem;">Close</button>
            `;
            document.body.appendChild(messageBox);
        }

        /**
         * Clears the given canvas context.
         * Also draws fallback text if no image is loaded for that context.
         * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
         */
        function clearCanvas(ctx) {
            if (ctx) {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                // Draw fallback text if no image is loaded
                let message = '';
                if ((ctx === originalCtx || ctx === normalCtx || ctx === roughnessCtx || ctx === aoCtx || ctx === metallicCtx || ctx === displacementCtx) && !sharedImage) {
                    message = 'No Image Loaded';
                }

                if ((ctx === originalCtx || ctx === normalCtx || ctx === roughnessCtx || ctx === aoCtx || ctx === metallicCtx || ctx === displacementCtx) && !sharedImage) {
                    ctx.fillStyle = '#6c757d'; // Darker grey text
                    ctx.font = '10px Inter, sans-serif'; // Even smaller font for message
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(message, ctx.canvas.width / 2, ctx.canvas.height / 2);
                } else if (!sharedImage && (ctx === colorExtractorCtx || ctx === pixelateCtx)) {
                    ctx.fillStyle = '#6c757d';
                    ctx.font = '12px Inter, sans-serif'; // Smaller font for main preview messages
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(message, ctx.canvas.width / 2, ctx.canvas.height / 2);
                }
            }
        }

        /**
         * Clears all canvases used by the Texture Weaver.
         */
        function clearAllCanvases() {
            clearCanvas(originalCtx);
            clearCanvas(normalCtx);
            clearCanvas(roughnessCtx);
            clearCanvas(aoCtx);
            clearCanvas(metallicCtx);
            clearCanvas(displacementCtx);
            clearCanvas(colorExtractorCtx);
            clearCanvas(pixelateCtx);
            // clearCanvas(largePreviewCtx); // Removed
        }

        /**
         * Converts an RGB color to grayscale luminosity.
         * @param {number} r - Red component (0-255).
         * @param {number} g - Green component (0-255).
         * @param {number} b - Blue component (0-255).
         * @returns {number} - Grayscale value (0-255).
         */
        function toGrayscale(r, g, b) {
            return 0.299 * r + 0.587 * g + 0.114 * b;
        }

        /**
         * Converts RGB to Hex color string.
         * @param {number} r
         * @param {number} g
         * @param {number} b
         * @returns {string} Hex color (e.g., "#RRGGBB")
         */
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        /**
         * Unified function to load an image and set it as the relevant image.
         * This function handles loading for all tabs to keep logic consistent.
         * Updates all file name displays and triggers relevant updates for the current tab.
         * @param {File} file - The image file object.
         * @param {HTMLElement} spinnerElement - The spinner associated with the input.
         * @param {HTMLInputElement} fileInput - The file input element that triggered the change.
         */
        function loadImageAndSetShared(file, spinnerElement, fileInput) {
            if (!file) {
                // If a file input is cleared, handle its specific image and display
                if (fileInput.id === 'textureInput') {
                    sharedImage = null;
                    sharedFileName = 'No image selected.';
                    // Reset the mesh scale and position to default when no image is loaded
                    if (mesh) {
                        mesh.scale.set(1, 1, 1);
                        mesh.position.y = 0;
                    }
                } else if (fileInput.id === 'colorImageInput') {
                    colorExtractorLocalImage = null;
                } else if (fileInput.id === 'pixelateImageInput') {
                    pixelateLocalImage = null;
                } else if (fileInput.id === 'meshImageInput') {
                    meshLocalImage = null;
                }
                updateAllFileDisplays();
                clearAllCanvases(); // Clear all canvas contents
                if (fileInput.id === 'textureInput') {
                    updateThreeJsTextures(); // Clear 3D textures if main image is removed
                }
                spinnerElement.style.display = 'none';
                return;
            }

            // Update file name display specific to the input
            if (fileInput.id === 'textureInput') {
                sharedFileName = file.name;
            } else if (fileInput.id === 'colorImageInput') {
                // Handled by updateAllFileDisplays
            } else if (fileInput.id === 'pixelateImageInput') {
                pixelateFileNameDisplay.textContent = file.name;
            } else if (fileInput.id === 'meshImageInput') {
                meshFileNameDisplay.textContent = file.name;
            }
            
            updateAllFileDisplays(); // Update all relevant filename displays

            spinnerElement.style.display = 'block';

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    spinnerElement.style.display = 'none';

                    if (fileInput.id === 'textureInput') {
                        sharedImage = img; // Main image for Texture Weaver and fallback
                    } else if (fileInput.id === 'colorImageInput') {
                        colorExtractorLocalImage = img; // Store image specific to Color Extractor tab
                    } else if (fileInput.id === 'pixelateImageInput') {
                        pixelateLocalImage = img; // Store image specific to Pixelate tab
                    } else if (fileInput.id === 'meshImageInput') {
                        meshLocalImage = img; // Store image specific to Image to Mesh tab
                    }
                    
                    applyEffectToCurrentTab(); // Always apply effect for current tab
                };
                img.onerror = function() {
                    spinnerElement.style.display = 'none';
                    showMessageBox("Error loading image. Please ensure it's a valid image file and not corrupted.", 'error');
                    // Reset specific image if it was the one that failed
                    if (fileInput.id === 'textureInput') { sharedImage = null; sharedFileName = "Error loading image."; }
                    else if (fileInput.id === 'stylizeImageInput') { stylizeLocalImage = null; stylizeFileNameDisplay.textContent = "Error loading image."; }
                    else if (fileInput.id === 'pixelateImageInput') { pixelateLocalImage = null; pixelateFileNameDisplay.textContent = "Error loading image."; }
                    else if (fileInput.id === 'meshImageInput') { meshLocalImage = null; meshFileNameDisplay.textContent = "Error loading image."; }
                    updateAllFileDisplays();
                };
                img.src = e.target.result;
            };
            reader.onerror = function() {
                spinnerElement.style.display = 'none';
                showMessageBox("Error reading image file. Please try again.", 'error');
                // Reset specific image if it was the one that failed
                if (fileInput.id === 'textureInput') { sharedImage = null; sharedFileName = "Error reading file."; }
                else if (fileInput.id === 'stylizeImageInput') { stylizeLocalImage = null; stylizeFileNameDisplay.textContent = "Error reading file."; }
                else if (fileInput.id === 'pixelateImageInput') { pixelateLocalImage = null; pixelateFileNameDisplay.textContent = "Error reading file."; }
                else if (fileInput.id === 'pixelateImageInput') { pixelateLocalImage = null; pixelateFileNameDisplay.textContent = "Error reading file."; }
                updateAllFileDisplays();
            };
            reader.readAsDataURL(file);
        }


        /**
         * Updates all file name display spans across different tabs.
         * Ensures that if a shared image is used, its name is reflected in other tabs.
         */
        function updateAllFileDisplays() {
            fileNameDisplay.textContent = sharedFileName;
            // For Color Extractor, check if a file is explicitly chosen, otherwise use shared image filename
            if (colorImageInput.files.length > 0) {
                colorFileNameDisplay.textContent = colorImageInput.files[0].name;
            } else {
                colorFileNameDisplay.textContent = sharedImage ? sharedFileName : 'No image selected.';
            }

            // For Stylize and Pixelate, prioritize their local image, then shared image
            pixelateFileNameDisplay.textContent = pixelateLocalImage ? pixelateLocalImage.name : (sharedImage ? sharedFileName : 'No image selected.');
            meshFileNameDisplay.textContent = meshLocalImage ? meshLocalImage.name : (sharedImage ? sharedFileName : 'No image selected.');
            
            // For Animation Combiner, show the count of multiple files
            if (characterFbxInput.files.length > 0) {
                characterFileNameDisplay.textContent = characterFbxInput.files[0].name;
            } else {
                characterFileNameDisplay.textContent = 'No character file selected.';
            }
            if (animationFbxInput.files.length > 0) {
                animationFileNameDisplay.textContent = `${animationFbxInput.files.length} animation(s) selected.`;
            } else {
                animationFileNameDisplay.textContent = 'No animation files selected.';
            }
        }

        /**
         * Applies the specific effect for the currently active tab.
         * This acts as a central dispatcher, calling the correct function based on `currentActiveTabId`.
         */
        function applyEffectToCurrentTab() {
            let imageToProcess = null;

            switch(currentActiveTabId) {
                case 'texture-pbr-tab':
                    imageToProcess = sharedImage;
                    if (!imageToProcess) {
                        clearCanvas(originalCtx);
                        clearCanvas(normalCtx);
                        clearCanvas(roughnessCtx);
                        clearCanvas(aoCtx);
                        clearCanvas(metallicCtx);
                        clearCanvas(displacementCtx);
                        updateThreeJsTextures();
                        return;
                    }
                    // 1. Draw to the small UI preview canvas
                    originalTextureCanvas.width = MAP_CANVAS_SIZE;
                    originalTextureCanvas.height = MAP_CANVAS_SIZE;
                    originalCtx.drawImage(imageToProcess, 0, 0, MAP_CANVAS_SIZE, MAP_CANVAS_SIZE);

                    // 2. Draw to the full-resolution offscreen canvas for the 3D texture
                    const fullResOriginalCtx = fullResOriginalCanvas.getContext('2d');
                    fullResOriginalCanvas.width = imageToProcess.width;
                    fullResOriginalCanvas.height = imageToProcess.height;
                    fullResOriginalCtx.drawImage(imageToProcess, 0, 0);

                    // Also draw to the pristine canvas to store the original state for non-destructive operations like seamlessing.
                    const pristineCtx = pristineSourceCanvas.getContext('2d');
                    pristineSourceCanvas.width = imageToProcess.width;
                    pristineSourceCanvas.height = imageToProcess.height;
                    pristineCtx.drawImage(imageToProcess, 0, 0);

                    // Adjust the 3D mesh scale and position to match the texture's aspect ratio
                    if (mesh && imageToProcess) {
                        const aspect = imageToProcess.width / imageToProcess.height;
                        const maxDim = 1.0; // The longest side of the box will be 1 unit.
                        let sx, sy, sz;

                        if (aspect > 1) { // Wider than tall (landscape)
                            sx = maxDim;
                            sy = maxDim / aspect;
                            sz = maxDim / aspect; // Keep depth proportional to the smaller side (height)
                        } else { // Taller than wide (portrait) or square
                            sx = maxDim * aspect;
                            sy = maxDim;
                            sz = maxDim * aspect; // Keep depth proportional to the smaller side (width)
                        }
                        mesh.scale.set(sx, sy, sz);
                        // Adjust position to sit on the ground plane
                        mesh.position.y = (sy / 2.0) - 0.5;
                    }

                    // 3. Generate all maps from the full-resolution source.
                    // This function will also handle updating the 3D view and UI previews.
                    generateMaps();
                    break;
                case 'color-extractor-tab':
                    imageToProcess = colorExtractorLocalImage || sharedImage; // Prioritize local, then shared
                    if (!imageToProcess) {
                        clearCanvas(colorExtractorCtx);
                        document.getElementById('extractedColorPalette').innerHTML = '<p class="text-center w-full text-gray-500 text-sm"></p>';
                        return;
                    }

                    // --- New Responsive Drawing Logic ---
                    const wrapper = colorExtractorCanvas.parentElement;
                    const maxWidth = wrapper.clientWidth;
                    const maxHeight = wrapper.clientHeight;

                    // Set the canvas drawing buffer size to its actual display size
                    colorExtractorCanvas.width = maxWidth;
                    colorExtractorCanvas.height = maxHeight;

                    const imgAspectRatio = imageToProcess.width / imageToProcess.height;
                    const canvasAspectRatio = maxWidth / maxHeight;

                    let renderWidth, renderHeight, x, y;

                    if (imgAspectRatio > canvasAspectRatio) {
                        // Image is wider than the canvas area
                        renderWidth = maxWidth;
                        renderHeight = maxWidth / imgAspectRatio;
                        x = 0;
                        y = (maxHeight - renderHeight) / 2; // Center vertically
                    } else {
                        // Image is taller than or has the same aspect ratio as the canvas area
                        renderHeight = maxHeight;
                        renderWidth = maxHeight * imgAspectRatio;
                        y = 0;
                        x = (maxWidth - renderWidth) / 2; // Center horizontally
                    }
                    colorExtractorCtx.drawImage(imageToProcess, x, y, renderWidth, renderHeight);
                    extractColorPalette(imageToProcess); // Pass the image
                    break;
                case 'pixelate-tab':
                    imageToProcess = pixelateLocalImage || sharedImage; // Prioritize pixelateLocalImage, then sharedImage
                    if (!imageToProcess) { clearCanvas(pixelateCtx); return; }
                    // Resize canvas based on client width/height but respect aspect ratio and max size
                    const aspectRatioPix = imageToProcess.width / imageToProcess.height;
                    let canvasWidthPix = imageToProcess.width;
                    let canvasHeightPix = imageToProcess.height;
                    if (canvasWidthPix > 600) { canvasWidthPix = 600; canvasHeightPix = 600 / aspectRatioPix; }
                    if (canvasHeightPix > 380) { canvasHeightPix = 380; canvasWidthPix = 380 * aspectRatioPix; }
                    pixelateCanvas.width = canvasWidthPix;
                    pixelateCanvas.height = canvasHeightPix;
                    pixelateCtx.drawImage(imageToProcess, 0, 0, canvasWidthPix, canvasHeightPix);
                    applyPixelateEffect();
                    break;
                case 'animation-combiner-tab':
                    // No image processing directly to canvases for this tab
                    break;
                case 'image-to-mesh-tab':
                    // The image processing happens inside the generate function
                    generateMeshFromImage();
                    break;
            }
        }

        /**
         * Generates a dynamic grid texture for the ground plane's default state.
         * @returns {THREE.CanvasTexture} A tileable grid texture.
         */
        function generateGridTexture() {
            const size = 256; // Texture resolution
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');

            // Dark bluish-gray background, matching typical 3D software.
            context.fillStyle = '#2d3748';
            context.fillRect(0, 0, size, size);

            // Light blue-gray grid lines for contrast and scale.
            context.strokeStyle = '#4a5568';
            context.lineWidth = 1;

            const divisions = 8; // 8x8 grid within the texture
            const step = size / divisions;

            for (let i = 0; i < size; i += step) {
                context.beginPath(); context.moveTo(0, i + 0.5); context.lineTo(size, i + 0.5); context.stroke(); // Horizontal
                context.beginPath(); context.moveTo(i + 0.5, 0); context.lineTo(i + 0.5, size); context.stroke(); // Vertical
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        /**
         * Resets the PBR camera and object rotation to their default state.
         */
        function resetPbrCamera() {
            if (camera && textureGroup) {
                // Reset camera zoom/position
                camera.position.set(0, 0.5, 2.5);
                // Reset object rotation
                textureGroup.rotation.set(0, 0, 0);
            }
        }

        /**
         * Resets the Image to Mesh camera to its saved initial state.
         */
        function resetImageToMeshCamera() {
            if (meshControls) meshControls.reset();
        }

        // --- Three.js Specific Functions ---

        /**
         * Initializes the Three.js scene, camera, renderer, and basic objects for Texture Weaver.
         * Also sets up responsive resizing and mouse controls for the 3D mesh.
         * @param {HTMLCanvasElement} canvasElement - The canvas DOM element for Three.js rendering.
         * @param {HTMLDivElement} textureWeaverTabElement - The texture weaver tab element for resize check.
         */
        function initThreeJsTextureWeaver(canvasElement, textureWeaverTabElement) {
            scene = new THREE.Scene(); // No background color, will be set by HDRI

            camera = new THREE.PerspectiveCamera(50, canvasElement.clientWidth / canvasElement.clientHeight, 0.1, 1000);
            camera.position.set(0, 0.5, 2.5); // Adjusted camera position for a better view
            camera.lookAt(scene.position); // Look at the center (0,0,0)


            try {
                renderer = new THREE.WebGLRenderer({ canvas: canvasElement, antialias: true });
                renderer.setSize(canvasElement.clientWidth, canvasElement.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 0.6; // Lower exposure to balance with the new sun light
                renderer.outputEncoding = THREE.sRGBEncoding; // Ensure correct color output
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            } catch (e) {
                console.error("DEBUG: Three.js Init Error: Failed to create WebGLRenderer for Texture Weaver:", e);
                showMessageBox(`Error initializing 3D preview: Your browser might not support WebGL.`, 'error');
                return;
            }

            // Load the HDRI environment map for realistic lighting and reflections
            new THREE.RGBELoader()
                .setDataType(THREE.UnsignedByteType) // Use UnsignedByteType for .hdr files
                // Use the version from the Three.js examples repo, which has the correct CORS headers.
                // The Polyhaven direct link does not, causing a loading error in the browser.
                .load('https://threejs.org/examples/textures/equirectangular/royal_esplanade_1k.hdr', function (texture) {
                    const pmremGenerator = new THREE.PMREMGenerator(renderer);
                    pmremGenerator.compileEquirectangularShader();
                    const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                    scene.background = envMap;
                    scene.environment = envMap; // Apply to all materials in the scene
                    texture.dispose();
                    pmremGenerator.dispose();
                }, undefined, (err) => {
                    console.error('An error occurred loading the HDRI.', err);
                    showMessageBox('Failed to load HDRI environment map. Using fallback lighting.', 'error');
                    scene.background = new THREE.Color(0x1a1a1a); // Fallback background
                });

            // Add a directional light to act as a controllable sun
            sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.castShadow = true;
            // Configure shadow properties for better quality
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 50;
            sunLight.shadow.camera.left = -10;
            sunLight.shadow.camera.right = 10;
            sunLight.shadow.camera.top = 10;
            sunLight.shadow.camera.bottom = -10;
            scene.add(sunLight);
            scene.add(sunLight.target);

            // Responsive renderer resize listener
            window.addEventListener('resize', () => {
                // Only resize if the texture weaver tab is active
                if (textureWeaverTabElement && textureWeaverTabElement.classList.contains('active')) {
                    camera.aspect = canvasElement.clientWidth / canvasElement.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(canvasElement.clientWidth, canvasElement.clientHeight);
                }
            });

            const geometry = new THREE.BoxGeometry(1, 1, 1, 64, 64, 64); // Increased segments for displacement
            textureWeaverMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 1.0,
                metalness: 0.0
            });

            // Create a group to hold the cube and the ground plane, so they rotate together
            textureGroup = new THREE.Group();
            scene.add(textureGroup);

            mesh = new THREE.Mesh(geometry, textureWeaverMaterial);
            mesh.castShadow = true; // The main object should cast shadows
            textureGroup.add(mesh);

            // Create the ground plane
            const planeSize = 10;
            const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize); // UVs are now default (0-1)

            // Create the default grid material for the ground when no texture is loaded.
            const gridTexture = generateGridTexture();
            // We now control tiling via the texture's repeat property, not by modifying geometry UVs.
            gridTexture.repeat.set(TILE_FACTOR, TILE_FACTOR);

            defaultGroundMaterial = new THREE.MeshStandardMaterial({
                map: gridTexture,
                roughness: 0.8,
                metalness: 0.1
            });

            // Also create the material for the ground when it's textured. This material will NOT have displacement.
            texturedGroundMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.8,
                metalness: 0.1
            });
            planeMesh = new THREE.Mesh(planeGeometry, defaultGroundMaterial); // Use the grid material by default
            planeMesh.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            planeMesh.position.y = -0.50; // Position it just below the cube
            planeMesh.receiveShadow = true; // The ground should receive shadows
            textureGroup.add(planeMesh);

            // The Ambient and Directional lights are no longer needed,
            // as the HDRI provides much more realistic image-based lighting.

            // Manual mouse controls for rotation (replacing OrbitControls)
            canvasElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
                canvasElement.style.cursor = 'grabbing';
            });

            canvasElement.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const deltaX = e.clientX - previousMouseX;
                const deltaY = e.clientY - previousMouseY;

                // Rotate group based on mouse movement
                textureGroup.rotation.y += deltaX * 0.005;
                textureGroup.rotation.x += deltaY * 0.005;

                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            });

            canvasElement.addEventListener('mouseup', () => {
                isDragging = false;
                canvasElement.style.cursor = 'grab';
            });

            canvasElement.addEventListener('mouseleave', () => {
                isDragging = false; // Stop dragging if mouse leaves canvas
                canvasElement.style.cursor = 'grab';
            });

            canvasElement.addEventListener('wheel', (e) => {
                e.preventDefault(); // Prevent the page from scrolling

                const zoomSpeed = 0.005;
                const minZoom = 1.5; // Prevent zooming in too close
                const maxZoom = 10;  // Prevent zooming out too far

                // Get the camera's current distance from the center (origin)
                let distance = camera.position.length();

                // Adjust the distance based on the scroll wheel delta
                distance += e.deltaY * zoomSpeed;

                // Clamp the distance to the min/max zoom limits
                distance = Math.max(minZoom, Math.min(maxZoom, distance));

                // Set the new camera position by scaling its direction vector
                camera.position.normalize().multiplyScalar(distance);
            });

            animateThreeJsTextureWeaver();
        }

        /**
        * Updates the sun's position and intensity based on the UI sliders.
        * Uses spherical coordinates for intuitive azimuth/elevation control.
        */
        function updateSunPosition() {
            if (!sunLight) return;

            const azimuth = THREE.MathUtils.degToRad(sunAzimuthSlider.value); // horizontal angle
            const elevation = THREE.MathUtils.degToRad(sunElevationSlider.value); // vertical angle
            const distance = 15; // Arbitrary distance from the origin

            // Calculate position from spherical coordinates
            // Y is up in Three.js
            sunLight.position.x = distance * Math.cos(elevation) * Math.sin(azimuth);
            sunLight.position.y = distance * Math.sin(elevation);
            sunLight.position.z = distance * Math.cos(elevation) * Math.cos(azimuth);

            sunLight.target.position.set(0, 0, 0); // Ensure it always points to the center
            sunLight.target.updateMatrixWorld(); // Update the target's matrix
            
            sunLight.intensity = parseFloat(sunIntensitySlider.value);

            // Update UI values
            sunAzimuthValue.textContent = sunAzimuthSlider.value + '°';
            sunElevationValue.textContent = sunElevationValue.textContent = sunElevationSlider.value + '°';
            sunIntensityValue.textContent = parseFloat(sunIntensitySlider.value).toFixed(2);
        }

        /**
         * Three.js animation loop for Texture Weaver.
         */
        function animateThreeJsTextureWeaver() {
            requestAnimationFrame(animateThreeJsTextureWeaver);
            
            // Auto-rotate the mesh if not being dragged
            if (!isDragging) {
                textureGroup.rotation.y += 0.001; // Adjust rotation speed as needed
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        /**
         * Updates the textures on the Three.js material for Texture Weaver.
         * Disposes old textures to prevent memory leaks and applies new ones from the 2D canvases.
         */
        function updateThreeJsTextures() {
            if (!textureWeaverMaterial) {
                return;
            }

            // Switch the plane's material based on whether a texture is loaded.
            if (sharedImage) {
                if (planeMesh && planeMesh.material !== texturedGroundMaterial) planeMesh.material = texturedGroundMaterial;
            } else {
                if (planeMesh && planeMesh.material !== defaultGroundMaterial) planeMesh.material = defaultGroundMaterial;
            }

            // Dispose old textures to free up GPU memory
            if (textureWeaverMaterial.map) textureWeaverMaterial.map.dispose();
            if (textureWeaverMaterial.normalMap) textureWeaverMaterial.normalMap.dispose();
            if (textureWeaverMaterial.roughnessMap) textureWeaverMaterial.roughnessMap.dispose();
            if (textureWeaverMaterial.aoMap) textureWeaverMaterial.aoMap.dispose();
            if (textureWeaverMaterial.metalnessMap) textureWeaverMaterial.metalnessMap.dispose();
            if (textureWeaverMaterial.displacementMap) textureWeaverMaterial.displacementMap.dispose();
            // Also dispose old ground textures, as they are separate objects now
            if (texturedGroundMaterial.map) texturedGroundMaterial.map.dispose();
            if (texturedGroundMaterial.normalMap) texturedGroundMaterial.normalMap.dispose();
            if (texturedGroundMaterial.roughnessMap) texturedGroundMaterial.roughnessMap.dispose();
            if (texturedGroundMaterial.aoMap) texturedGroundMaterial.aoMap.dispose();
            if (texturedGroundMaterial.metalnessMap) texturedGroundMaterial.metalnessMap.dispose();

            const aspect = sharedImage ? sharedImage.width / sharedImage.height : 1;

            // Helper to create a base texture with wrapping, but no aspect correction.
            const createBaseTexture = (canvas) => {
                if (!canvas || !sharedImage) return null;
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                return texture;
            };

            // Create new CanvasTextures for the main box material (no UV aspect correction)
            textureWeaverMaterial.map = createBaseTexture(fullResOriginalCanvas);
            textureWeaverMaterial.normalMap = createBaseTexture(fullResNormalCanvas);
            textureWeaverMaterial.roughnessMap = createBaseTexture(fullResRoughnessCanvas);
            textureWeaverMaterial.aoMap = createBaseTexture(fullResAoCanvas);
            textureWeaverMaterial.metalnessMap = createBaseTexture(fullResMetallicCanvas);
            textureWeaverMaterial.displacementMap = createBaseTexture(fullResDisplacementCanvas);

            // Set appropriate sRGBEncoding for color maps (albedo)
            if (textureWeaverMaterial.map) textureWeaverMaterial.map.encoding = THREE.sRGBEncoding;

            // Apply slider values to the material properties (3D Material Properties)
            if (normalStrengthSlider) textureWeaverMaterial.normalScale.set(parseFloat(normalStrengthSlider.value), parseFloat(normalStrengthSlider.value));
            textureWeaverMaterial.roughness = 1.0; // Let the map control roughness entirely
            if (aoIntensitySlider) textureWeaverMaterial.aoMapIntensity = parseFloat(aoIntensitySlider.value);
            textureWeaverMaterial.metalness = 1.0; // Let the map control metalness entirely
            if (displacementScaleSlider) textureWeaverMaterial.displacementScale = parseFloat(displacementScaleSlider.value);
            if (displacementBiasSlider) textureWeaverMaterial.displacementBias = parseFloat(displacementBiasSlider.value);

            // Update the GROUND material with CLONED textures and apply aspect correction
            if (texturedGroundMaterial && sharedImage) {
                // Helper to clone a texture and apply aspect ratio correction for the ground plane.
                const setupGroundTexture = (sourceTexture) => {
                    if (!sourceTexture) return null;
                    const groundTexture = sourceTexture.clone();
                    groundTexture.needsUpdate = true; // Essential after cloning
                    
                    // New logic: Make the ground tiles have the same aspect ratio as the texture.
                    if (aspect >= 1) { // Wider than or equal to tall (square)
                        groundTexture.repeat.set(TILE_FACTOR, TILE_FACTOR * aspect);
                    } else { // Taller than wide
                        groundTexture.repeat.set(TILE_FACTOR / aspect, TILE_FACTOR);
                    }
                    groundTexture.offset.set(0, 0); // Reset offset, no longer needed
                    return groundTexture;
                };

                texturedGroundMaterial.map = setupGroundTexture(textureWeaverMaterial.map);
                texturedGroundMaterial.normalMap = setupGroundTexture(textureWeaverMaterial.normalMap);
                texturedGroundMaterial.roughnessMap = setupGroundTexture(textureWeaverMaterial.roughnessMap);
                texturedGroundMaterial.aoMap = setupGroundTexture(textureWeaverMaterial.aoMap);
                texturedGroundMaterial.metalnessMap = setupGroundTexture(textureWeaverMaterial.metalnessMap);
                texturedGroundMaterial.displacementMap = null; // Explicitly disable displacement

                texturedGroundMaterial.normalScale.copy(textureWeaverMaterial.normalScale);
                texturedGroundMaterial.aoMapIntensity = textureWeaverMaterial.aoMapIntensity;
                texturedGroundMaterial.displacementScale = 0;
                texturedGroundMaterial.displacementBias = 0;
                texturedGroundMaterial.needsUpdate = true;
            } else {
                // Clear ground textures if no image
                texturedGroundMaterial.map = null;
                texturedGroundMaterial.normalMap = null;
                texturedGroundMaterial.roughnessMap = null;
                texturedGroundMaterial.aoMap = null;
                texturedGroundMaterial.metalnessMap = null;
            }

            // --- NEW: Sync with Image-to-Mesh Material ---
            // If the generated mesh from the other tab exists, update its material too.
            syncMeshMaterialFromPbr();

            // Ensure material updates
            textureWeaverMaterial.needsUpdate = true;
        }
        
        /**
         * Sets the 3D preview to isolate a single map or restore the full PBR view.
         * @param {string} mapType - The 'data-map-type' of the clicked canvas container.
         */
        function set3DPreviewMode(mapType) {
            if (!textureWeaverMaterial || !sharedImage) return;

            // Remove active state from all containers first
            document.querySelectorAll('.map-grid .canvas-container').forEach(c => c.classList.remove('isolated-view'));

            // If we want to restore the full PBR view, clicking 'Original' or the currently isolated map does this.
            if (mapType === 'Original Texture') {
                updateThreeJsTextures(); // This function restores the full PBR material for both cube and ground
                return;
            }
            // If clicking the already isolated map, restore the view.
            const container = document.querySelector(`.map-grid .canvas-container[data-map-type="${mapType}"]`);
            if (container && container.classList.contains('isolated-view')) {
                container.classList.remove('isolated-view');
                updateThreeJsTextures();
                return;
            }

            // --- Isolate a specific map ---

            // Add active state to the clicked container for visual feedback
            if (container) {
                container.classList.add('isolated-view');
            }

            // Since textures are shared, we only need to dispose the main material's maps.
            // The ground material's references will become invalid, which is what we want before re-assigning.
            if (textureWeaverMaterial.map) textureWeaverMaterial.map.dispose();
            if (textureWeaverMaterial.normalMap) textureWeaverMaterial.normalMap.dispose();
            if (textureWeaverMaterial.roughnessMap) textureWeaverMaterial.roughnessMap.dispose();
            if (textureWeaverMaterial.aoMap) textureWeaverMaterial.aoMap.dispose();
            if (textureWeaverMaterial.metalnessMap) textureWeaverMaterial.metalnessMap.dispose();
            if (textureWeaverMaterial.displacementMap) textureWeaverMaterial.displacementMap.dispose();

            // Reset BOTH materials to a neutral state for viewing a single map
            const neutralProps = {
                map: null, normalMap: null, roughnessMap: null, aoMap: null, metalnessMap: null, displacementMap: null,
                aoMapIntensity: 0.0,
                roughness: 0.5, metalness: 0.0
            };
            Object.assign(textureWeaverMaterial, neutralProps);
            textureWeaverMaterial.displacementScale = 0.0;
            textureWeaverMaterial.displacementBias = 0.0;
            textureWeaverMaterial.normalScale.set(0, 0);

            // Also reset the ground material to a neutral state
            if (texturedGroundMaterial) {
                Object.assign(texturedGroundMaterial, neutralProps);
                texturedGroundMaterial.displacementScale = 0.0;
                texturedGroundMaterial.displacementBias = 0.0;
                texturedGroundMaterial.normalScale.set(0, 0);
            }
            const sourceCanvasMap = {
                'Normal Map': fullResNormalCanvas,
                'Roughness Map': fullResRoughnessCanvas,
                'Ambient Occlusion Map': fullResAoCanvas,
                'Metallic Map': fullResMetallicCanvas,
                'Displacement Map': fullResDisplacementCanvas
            };

            const aspect = sharedImage ? sharedImage.width / sharedImage.height : 1;
            const sourceCanvas = sourceCanvasMap[mapType];

            if (sourceCanvas) {
                // Create the base texture for the box (no UV correction)
                const boxPreviewTexture = new THREE.CanvasTexture(sourceCanvas);
                boxPreviewTexture.wrapS = THREE.RepeatWrapping;
                boxPreviewTexture.wrapT = THREE.RepeatWrapping;
                boxPreviewTexture.encoding = THREE.sRGBEncoding;
                boxPreviewTexture.needsUpdate = true;
                
                textureWeaverMaterial.map = boxPreviewTexture;

                // Create a cloned, aspect-corrected texture for the ground
                if (texturedGroundMaterial) {
                    const groundPreviewTexture = boxPreviewTexture.clone();
                    
                    // Apply the same aspect-ratio-aware tiling to the isolated preview
                    if (aspect >= 1) { // Wider than or equal to tall (square)
                        groundPreviewTexture.repeat.set(TILE_FACTOR, TILE_FACTOR * aspect);
                    } else { // Taller than wide
                        groundPreviewTexture.repeat.set(TILE_FACTOR / aspect, TILE_FACTOR);
                    }
                    groundPreviewTexture.offset.set(0, 0);
                    groundPreviewTexture.needsUpdate = true; // Essential after clone and modification
                    texturedGroundMaterial.map = groundPreviewTexture;
                }
            }

            textureWeaverMaterial.needsUpdate = true;
            if (texturedGroundMaterial) texturedGroundMaterial.needsUpdate = true;
        }

        /**
         * Synchronizes the material of the generated mesh in the "Image to Mesh" tab
         * with the current state of the main PBR material.
         */
        function syncMeshMaterialFromPbr() {
            if (!generatedMesh || !generatedMesh.material || !textureWeaverMaterial || !sharedImage) {
                return;
            }

            const meshMaterial = generatedMesh.material;

            // Dispose old textures on the mesh material to prevent memory leaks
            if (meshMaterial.map) meshMaterial.map.dispose();
            if (meshMaterial.normalMap) meshMaterial.normalMap.dispose();
            if (meshMaterial.roughnessMap) meshMaterial.roughnessMap.dispose();
            if (meshMaterial.aoMap) meshMaterial.aoMap.dispose();
            if (meshMaterial.metalnessMap) meshMaterial.metalnessMap.dispose();

            // Helper to clone a texture for the mesh material.
            const cloneForMesh = (sourceTexture) => {
                if (!sourceTexture || !sourceTexture.image) return null;
                const newTexture = sourceTexture.clone();
                newTexture.needsUpdate = true;
                newTexture.wrapS = THREE.ClampToEdgeWrapping;
                newTexture.wrapT = THREE.ClampToEdgeWrapping;
                return newTexture;
            };

            // Clone textures and copy properties from the PBR material
            meshMaterial.map = cloneForMesh(textureWeaverMaterial.map);
            meshMaterial.normalMap = cloneForMesh(textureWeaverMaterial.normalMap);
            meshMaterial.roughnessMap = cloneForMesh(textureWeaverMaterial.roughnessMap);
            meshMaterial.aoMap = cloneForMesh(textureWeaverMaterial.aoMap);
            meshMaterial.metalnessMap = cloneForMesh(textureWeaverMaterial.metalnessMap);
            meshMaterial.normalScale.copy(textureWeaverMaterial.normalScale);
            meshMaterial.aoMapIntensity = textureWeaverMaterial.aoMapIntensity;
            meshMaterial.roughness = textureWeaverMaterial.roughness;
            meshMaterial.metalness = textureWeaverMaterial.metalness;
            meshMaterial.needsUpdate = true;
        }

        // --- Texture Weaver Core Logic Functions ---

        /**
         * Calls all map generation functions for texture weaver.
         * This is the main trigger after an image is loaded or a 2D adjustment slider is moved.
         */
        function generateMaps() {
            if (!sharedImage) {
                clearCanvas(originalCtx);
                clearCanvas(normalCtx);
                clearCanvas(roughnessCtx);
                clearCanvas(aoCtx);
                clearCanvas(metallicCtx);
                clearCanvas(displacementCtx);
                return;
            }
            // Generate all maps using the full-resolution canvases as source and destination
            generateNormalMap(fullResOriginalCanvas, fullResNormalCanvas, invertNormalYCheckbox.checked);
            generateRoughnessMap(fullResOriginalCanvas, fullResRoughnessCanvas, parseFloat(roughnessIntensitySlider.value));
            generateAOMap(fullResOriginalCanvas, fullResAoCanvas, parseFloat(aoContrastSlider.value));
            generateMetallicMap(fullResOriginalCanvas, fullResMetallicCanvas, parseFloat(metallicSharpnessSlider.value), invertMetallicCheckbox.checked);
            generateDisplacementMap(fullResOriginalCanvas, fullResDisplacementCanvas, parseFloat(displacementDetailSlider.value));

            // After generating full-res maps, update the small UI previews and the 3D model
            updatePreviewCanvases();
            updateThreeJsTextures();
        }

        /**
         * Copies the content from the full-resolution offscreen canvases
         * to the small 90x90 preview canvases in the UI.
         */
        function updatePreviewCanvases() {
            // Helper to copy from a full-res canvas to a small preview canvas
            const copyToPreview = (sourceCanvas, destCtx) => {
                if (sharedImage && destCtx) {
                    destCtx.clearRect(0, 0, destCtx.canvas.width, destCtx.canvas.height);
                    destCtx.drawImage(sourceCanvas, 0, 0, destCtx.canvas.width, destCtx.canvas.height);
                } else if (destCtx) {
                    clearCanvas(destCtx);
                }
            };

            copyToPreview(fullResNormalCanvas, normalCtx);
            copyToPreview(fullResRoughnessCanvas, roughnessCtx);
            copyToPreview(fullResAoCanvas, aoCtx);
            copyToPreview(fullResMetallicCanvas, metallicCtx);
            copyToPreview(fullResDisplacementCanvas, displacementCtx);
        }


        // --- Map Generation Functions (Updated with new parameters) ---

        /**
         * Generates a Normal Map from a grayscale version of the source image.
         * Uses a Sobel operator to calculate gradients and encode them as RGB values.
         * @param {HTMLCanvasElement} sourceCanvas The canvas with the original image.
         * @param {HTMLCanvasElement} targetCanvas The canvas to draw the normal map on.
         * @param {boolean} invertY Whether to invert the Y (green) channel.
         */
        function generateNormalMap(sourceCanvas, targetCanvas, invertY) {
            if (!sourceCanvas || !targetCanvas || !targetCanvas.getContext('2d') || !sharedImage) {
                clearCanvas(targetCanvas.getContext('2d'));
                return;
            }
            targetCanvas.width = sourceCanvas.width;
            targetCanvas.height = sourceCanvas.height;

            const sourceCtx = sourceCanvas.getContext('2d');
            const targetCtx = targetCanvas.getContext('2d');

            const imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
            const data = imageData.data;
            const newImageData = targetCtx.createImageData(sourceCanvas.width, sourceCanvas.height);
            const newData = newImageData.data;

            const width = sourceCanvas.width;
            const height = sourceCanvas.height;

            const gx = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
            const gy = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

            function getPixelGrayscale(x, y) {
                if (x < 0 || x >= width || y < 0 || y >= height) {
                    x = Math.max(0, Math.min(width - 1, x));
                    y = Math.max(0, Math.min(height - 1, y));
                }
                const i = (y * width + x) * 4;
                return toGrayscale(data[i], data[i + 1], data[i + 2]);
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let sumX = 0;
                    let sumY = 0;

                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const pixelGray = getPixelGrayscale(x + kx, y + ky);
                            const kernelIndex = (ky + 1) * 3 + (kx + 1);
                            sumX += pixelGray * gx[kernelIndex];
                            sumY += pixelGray * gy[kernelIndex];
                        }
                    }

                    const maxGradient = 1020;
                    let normalX = sumX / maxGradient;
                    let normalY = sumY / maxGradient;
                    let normalZ = 1.0; 

                    const length = Math.sqrt(normalX * normalX + normalY * normalY + normalZ * normalZ);
                    if (length > 0) {
                        normalX /= length;
                        normalY /= length;
                        normalZ /= length;
                    }

                    const r = Math.floor((normalX * 0.5 + 0.5) * 255);
                    let g;
                    if (invertY) {
                        g = Math.floor((0.5 - normalY * 0.5) * 255);
                    } else {
                        g = Math.floor((normalY * 0.5 + 0.5) * 255);
                    }
                    const b = Math.floor((normalZ * 0.5 + 0.5) * 255);

                    const i = (y * width + x) * 4;
                    newData[i] = r;
                    newData[i + 1] = g;
                    newData[i + 2] = b;
                    newData[i + 3] = 255;
                }
            }
            targetCtx.putImageData(newImageData, 0, 0);
        }

        /**
         * Generates a simulated Roughness Map with intensity control.
         * Darker areas of the original image become less rough (smoother), lighter areas become more rough.
         * @param {HTMLCanvasElement} sourceCanvas - The canvas containing the original texture.
         * @param {HTMLCanvasElement} targetCanvas - The canvas to draw the roughness map on.
         * @param {number} intensity - Multiplier for roughness value (0.0 to 2.0).
         */
        function generateRoughnessMap(sourceCanvas, targetCanvas, intensity) {
            if (!sourceCanvas || !targetCanvas || !targetCanvas.getContext('2d') || !sharedImage) {
                clearCanvas(targetCanvas.getContext('2d'));
                return;
            }
            targetCanvas.width = sourceCanvas.width;
            targetCanvas.height = sourceCanvas.height;

            const sourceCtx = sourceCanvas.getContext('2d');
            const targetCtx = targetCanvas.getContext('2d');

            const imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
            const data = imageData.data;
            const newImageData = targetCtx.createImageData(sourceCanvas.width, sourceCanvas.height);
            const newData = newImageData.data;

            for (let i = 0; i < data.length; i += 4) {
                let gray = toGrayscale(data[i], data[i + 1], data[i + 2]);
                gray = Math.max(0, Math.min(255, gray * intensity)); // Apply intensity and clamp

                newData[i] = gray;
                newData[i + 1] = gray;
                newData[i + 2] = gray;
                newData[i + 3] = 255;
            }
            targetCtx.putImageData(newImageData, 0, 0);
        }

        /**
         * Generates a simulated Ambient Occlusion (AO) Map with contrast control.
         * Inverts the grayscale values of the original image to simulate shadows in crevices.
         * @param {HTMLCanvasElement} sourceCanvas - The canvas containing the original texture.
         * @param {HTMLCanvasElement} targetCanvas - The canvas to draw the AO map on.
         * @param {number} contrast - Multiplier for AO contrast (0.0 to 2.0).
         */
        function generateAOMap(sourceCanvas, targetCanvas, contrast) {
            if (!sourceCanvas || !targetCanvas || !targetCanvas.getContext('2d') || !sharedImage) {
                clearCanvas(targetCanvas.getContext('2d'));
                return;
            }
            targetCanvas.width = sourceCanvas.width;
            targetCanvas.height = sourceCanvas.height;

            const sourceCtx = sourceCanvas.getContext('2d');
            const targetCtx = targetCanvas.getContext('2d');

            const imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
            const data = imageData.data;
            const newImageData = targetCtx.createImageData(sourceCanvas.width, sourceCanvas.height);
            const newData = newImageData.data;

            for (let i = 0; i < data.length; i += 4) {
                let gray = toGrayscale(data[i], data[i + 1], data[i + 2]);
                let aoValue = 255 - gray; // Base AO value (inverted grayscale)
                
                // Apply contrast: (value - 128) * contrast + 128, then clamp
                aoValue = (aoValue - 128) * contrast + 128;
                aoValue = Math.max(0, Math.min(255, aoValue));

                newData[i] = aoValue;
                newData[i + 1] = aoValue;
                newData[i + 2] = aoValue;
                newData[i + 3] = 255;
            }
            targetCtx.putImageData(newImageData, 0, 0);
        }

        /**
         * Generates a simulated Metallic Map with sharpness control.
         * Uses a simple threshold on the grayscale values to create a black and white mask.
         * @param {HTMLCanvasElement} sourceCanvas - The canvas containing the original texture.
         * @param {HTMLCanvasElement} targetCanvas - The canvas to draw the metallic map on.
         * @param {number} sharpness - Controls the threshold/contrast of metallic areas (0.0 to 1.0).
         * @param {boolean} invert - Whether to invert the final black/white map.
         */
        function generateMetallicMap(sourceCanvas, targetCanvas, sharpness, invert) {
            if (!sourceCanvas || !targetCanvas || !targetCanvas.getContext('2d') || !sharedImage) {
                clearCanvas(targetCanvas.getContext('2d'));
                return;
            }
            targetCanvas.width = sourceCanvas.width;
            targetCanvas.height = sourceCanvas.height;

            const sourceCtx = sourceCanvas.getContext('2d');
            const targetCtx = targetCanvas.getContext('2d');

            const imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
            const data = imageData.data;
            const newImageData = targetCtx.createImageData(sourceCanvas.width, sourceCanvas.height);
            const newData = newImageData.data;

            for (let i = 0; i < data.length; i += 4) {
                let gray = toGrayscale(data[i], data[i + 1], data[i + 2]);
                
                // Simple thresholding based on sharpness
                // sharpness close to 0.0 makes more black (non-metallic), close to 1.0 makes more white (metallic)
                if (sharpness <= 0.5) { // More towards non-metallic
                    gray = (gray > (255 * sharpness * 2)) ? 255 : 0;
                } else { // More towards metallic
                    gray = (gray > (255 * sharpness)) ? 255 : 0;
                }
                
                // Invert the value if the checkbox is checked
                if (invert) {
                    gray = 255 - gray;
                }

                newData[i] = gray;
                newData[i + 1] = gray;
                newData[i + 2] = gray;
                newData[i + 3] = 255;
            }
            targetCtx.putImageData(newImageData, 0, 0);
        }

        /**
         * Generates a simulated Displacement Map with detail control.
         * Uses the grayscale values of the original image to represent height data.
         * @param {HTMLCanvasElement} sourceCanvas - The canvas containing the original texture.
         * @param {HTMLCanvasElement} targetCanvas - The canvas to draw the displacement map on.
         * @param {number} detail - Multiplier for height variation (0.0 to 2.0).
         */
        function generateDisplacementMap(sourceCanvas, targetCanvas, detail) {
            if (!sourceCanvas || !targetCanvas || !targetCanvas.getContext('2d') || !sharedImage) {
                clearCanvas(targetCanvas.getContext('2d'));
                return;
            }
            targetCanvas.width = sourceCanvas.width;
            targetCanvas.height = sourceCanvas.height;

            const sourceCtx = sourceCanvas.getContext('2d');
            const targetCtx = targetCanvas.getContext('2d');

            const imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
            const data = imageData.data;
            const newImageData = targetCtx.createImageData(sourceCanvas.width, sourceCanvas.height);
            const newData = newImageData.data;

            for (let i = 0; i < data.length; i += 4) {
                let gray = toGrayscale(data[i], data[i + 1], data[i + 2]);
                
                // Apply detail: (value - 128) * detail + 128, then clamp
                // This increases contrast around mid-gray, enhancing perceived detail
                gray = (gray - 128) * detail + 128;
                gray = Math.max(0, Math.min(255, gray));

                newData[i] = gray;
                newData[i + 1] = gray;
                newData[i + 2] = gray;
                newData[i + 3] = 255;
            }
            targetCtx.putImageData(newImageData, 0, 0);
        }

        /**
         * Dispatches to the correct seamless function based on the user's selection.
         */
        function makeSourceTextureSeamless() {
            if (!sharedImage) {
                showMessageBox('Please upload an image first.', 'error');
                return;
            }

            const method = seamlessMethodSelect.value;

            if (method === 'mirror') {
                makeSeamlessMirror();
            } else if (method === 'blend') {
                const radius = parseInt(seamlessRadiusSlider.value);
                const intensity = parseInt(seamlessIntensitySlider.value);
                makeSeamlessBlend(radius, intensity);
            }
        }

        /**
         * Makes the source texture seamless using an edge-blending (cross-fade) technique.
         * @param {number} radius The width of the blend area in pixels.
         * @param {number} intensity The strength of the effect (0-100). 0 is disabled.
         */
        function makeSeamlessBlend(radius, intensity) {
            if (intensity === 0) {
                // Restore the original image if the effect is disabled
                const destCtx = fullResOriginalCanvas.getContext('2d');
                destCtx.drawImage(pristineSourceCanvas, 0, 0);
                generateMaps();
                showMessageBox('Seamless blend disabled. Original texture restored.', 'info');
                return;
            }

            const sourceCanvas = pristineSourceCanvas;
            const destCanvas = fullResOriginalCanvas;
            const destCtx = destCanvas.getContext('2d');
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;

            destCanvas.width = width;
            destCanvas.height = height;
            destCtx.drawImage(sourceCanvas, 0, 0);

            // --- Horizontal Blend ---
            const leftStrip = destCtx.getImageData(0, 0, radius, height);
            const rightStrip = destCtx.getImageData(width - radius, 0, radius, height);
            const leftData = leftStrip.data;
            const rightData = rightStrip.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < radius; x++) {
                    const alpha = x / (radius - 1.0);
                    const i = (y * radius + x) * 4;
                    for (let c = 0; c < 3; c++) { // RGB
                        const l = leftData[i + c];
                        const r = rightData[i + c];
                        leftData[i + c] = l * (1 - alpha) + r * alpha;
                        rightData[i + c] = r * (1 - alpha) + l * alpha;
                    }
                }
            }
            destCtx.putImageData(leftStrip, 0, 0);
            destCtx.putImageData(rightStrip, width - radius, 0);

            // --- Vertical Blend ---
            const topStrip = destCtx.getImageData(0, 0, width, radius);
            const bottomStrip = destCtx.getImageData(0, height - radius, width, radius);
            const topData = topStrip.data;
            const bottomData = bottomStrip.data;

            for (let x = 0; x < width; x++) {
                for (let y = 0; y < radius; y++) {
                    const alpha = y / (radius - 1.0);
                    const i = (y * width + x) * 4;
                    for (let c = 0; c < 3; c++) { // RGB
                        const t = topData[i + c];
                        const b = bottomData[i + c];
                        topData[i + c] = t * (1 - alpha) + b * alpha;
                        bottomData[i + c] = b * (1 - alpha) + t * alpha;
                    }
                }
            }
            destCtx.putImageData(topStrip, 0, 0);
            destCtx.putImageData(bottomStrip, 0, height - radius);

            // --- Final Intensity Blend ---
            const intensityFactor = intensity / 100.0;
            const finalImageData = destCtx.getImageData(0, 0, width, height);
            const finalData = finalImageData.data;
            const pristineData = sourceCanvas.getContext('2d').getImageData(0, 0, width, height).data;
            for (let i = 0; i < finalData.length; i++) {
                finalData[i] = pristineData[i] * (1 - intensityFactor) + finalData[i] * intensityFactor;
            }
            destCtx.putImageData(finalImageData, 0, 0);

            generateMaps();
            showMessageBox('Texture made seamless using Blend method. All maps have been regenerated.', 'success');
        }

        /**
         * Makes the source texture seamless using a 9-slice mirroring technique (the original method).
         * This is a robust method for creating tileable textures by mirroring the
         * original image into a 3x3 grid and then extracting the center tile.
         */
        function makeSeamlessMirror() {
            // The source is the PRISTINE, unmodified canvas
            const sourceCanvas = pristineSourceCanvas;
            // The destination is the WORKING canvas that all other tools use
            const destCanvas = fullResOriginalCanvas;
            const destCtx = destCanvas.getContext('2d');
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;

            // Ensure destination canvas has the same size
            destCanvas.width = width;
            destCanvas.height = height;

            // Create a temporary canvas 3x the size to build the seamless texture
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width * 3;
            tempCanvas.height = height * 3;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw the 9-slice grid of mirrored images from the PRISTINE source
            // Center
            tempCtx.drawImage(sourceCanvas, width, height);
            // Top
            tempCtx.save(); tempCtx.scale(1, -1); tempCtx.drawImage(sourceCanvas, width, -height); tempCtx.restore();
            // Bottom
            tempCtx.save(); tempCtx.scale(1, -1); tempCtx.drawImage(sourceCanvas, width, -(height * 3)); tempCtx.restore();
            // Left
            tempCtx.save(); tempCtx.scale(-1, 1); tempCtx.drawImage(sourceCanvas, -width, height); tempCtx.restore();
            // Right
            tempCtx.save(); tempCtx.scale(-1, 1); tempCtx.drawImage(sourceCanvas, -(width * 3), height); tempCtx.restore();
            // Top-Left
            tempCtx.save(); tempCtx.scale(-1, -1); tempCtx.drawImage(sourceCanvas, -width, -height); tempCtx.restore();
            // Top-Right
            tempCtx.save(); tempCtx.scale(-1, -1); tempCtx.drawImage(sourceCanvas, -(width * 3), -height); tempCtx.restore();
            // Bottom-Left
            tempCtx.save(); tempCtx.scale(-1, -1); tempCtx.drawImage(sourceCanvas, -width, -(height * 3)); tempCtx.restore();
            // Bottom-Right
            tempCtx.save(); tempCtx.scale(-1, -1); tempCtx.drawImage(sourceCanvas, -(width * 3), -(height * 3)); tempCtx.restore();

            // Now, copy the central part of the large canvas back to the WORKING canvas
            destCtx.clearRect(0, 0, width, height);
            destCtx.drawImage(tempCanvas, width, height, width, height, 0, 0, width, height);

            // The source canvas is now seamless. Regenerate everything.
            generateMaps();

            showMessageBox('Texture made seamless using Mirror method. All maps have been regenerated.', 'success');
        }


        /**
         * Exports all selected maps as a single ZIP file at the chosen resolution.
         * Uses the JSZip library to create the archive in the browser.
         */
        async function exportAllMaps() {
            if (!sharedImage) {
                showMessageBox('Please upload an image first to generate maps for export.', 'error');
                return;
            }

            let exportSize;
            const originalWidth = sharedImage.width;
            const originalHeight = sharedImage.height;

            if (exportResolutionSelect.value === 'original') {
                exportSize = originalWidth; // Use original width for non-square exports
            } else {
                exportSize = parseInt(exportResolutionSelect.value);
            }
            
            const baseFileName = sharedFileName.split('.').slice(0, -1).join('.') || 'exported_texture';

            // CRITICAL FIX: Use the full-resolution canvases for export, not the small UI previews.
            const mapsToExport = [];
            if (exportOriginalTextureCheckbox.checked) mapsToExport.push({ canvas: fullResOriginalCanvas, name: 'original' });
            if (exportNormalMapCheckbox.checked) mapsToExport.push({ canvas: fullResNormalCanvas, name: 'normal' });
            if (exportRoughnessMapCheckbox.checked) mapsToExport.push({ canvas: fullResRoughnessCanvas, name: 'roughness' });
            if (exportAOMapCheckbox.checked) mapsToExport.push({ canvas: fullResAoCanvas, name: 'ao' });
            if (exportMetallicMapCheckbox.checked) mapsToExport.push({ canvas: fullResMetallicCanvas, name: 'metallic' });
            if (exportDisplacementMapCheckbox.checked) mapsToExport.push({ canvas: fullResDisplacementCanvas, name: 'displacement' });

            if (mapsToExport.length === 0) {
                showMessageBox('Please select at least one map to export.', 'info');
                return;
            }

            const zip = new JSZip();

            for (const mapInfo of mapsToExport) {
                const blob = await new Promise(resolve => {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    // Handle non-square exports correctly when 'original' is selected
                    tempCanvas.width = (exportResolutionSelect.value === 'original') ? originalWidth : exportSize;
                    tempCanvas.height = (exportResolutionSelect.value === 'original') ? originalHeight : exportSize;
                    tempCtx.drawImage(mapInfo.canvas, 0, 0, tempCanvas.width, tempCanvas.height);
                    tempCanvas.toBlob(resolve, 'image/png');
                });
                zip.file(`${baseFileName}_${mapInfo.name}.png`, blob);
            }

            zip.generateAsync({ type: "blob" }).then(function(content) {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(content);
                a.download = `${baseFileName}_maps.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href); // Clean up the URL object
                showMessageBox(`${mapsToExport.length} map(s) exported as a ZIP file.`, 'success');
            }).catch(e => {
                console.error("Error generating zip file:", e);
                showMessageBox("Failed to generate ZIP file for export.", 'error');
            });
        }


        // --- Color Palette Extractor Specific Functions ---

        /**
         * Extracts dominant colors from the image on the colorExtractorCanvas.
         * Downsamples the image, quantizes colors to reduce the color space, and counts frequencies.
         * Uses a simple pixel sampling and frequency counting method.
         * @param {HTMLImageElement} imageToProcess - The image to extract colors from.
         */

         /* Extract Theme */
        function extractColorPalette(imageToProcess) {
            const paletteDiv = document.getElementById('extractedColorPalette');
            if (!imageToProcess) {
                clearCanvas(colorExtractorCtx);
                paletteDiv.innerHTML = '<p class="text-center w-full text-gray-500 text-sm"></p>';
                return;
            }

            const numColors = parseInt(numColorsSlider.value);
            paletteDiv.innerHTML = ''; // Clear previous palette

            // Downsample image for faster processing if it's too large
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            const sampleSize = 100; // Sample to 100x100 for color extraction speed
            tempCanvas.width = sampleSize;
            tempCanvas.height = sampleSize;
            tempCtx.drawImage(imageToProcess, 0, 0, sampleSize, sampleSize);

            const imageData = tempCtx.getImageData(0, 0, sampleSize, sampleSize);
            const pixels = imageData.data;
            const colorCounts = {};

            // Collect pixel data and count frequencies
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                // Simple quantization to reduce unique colors for counting
                const quantizeFactor = 16; // Adjust for more/less precision
                const qr = Math.floor(r / quantizeFactor) * quantizeFactor;
                const qg = Math.floor(g / quantizeFactor) * quantizeFactor;
                const qb = Math.floor(b / quantizeFactor) * quantizeFactor;
                const colorKey = `${qr},${qg},${qb}`;
                colorCounts[colorKey] = (colorCounts[colorKey] || 0) + 1;
            }

            // Sort colors by frequency
            const sortedColors = Object.entries(colorCounts).sort((a, b) => b[1] - a[1]);

            // Take the top N colors
            const extractedColors = [];
            for (let i = 0; i < Math.min(numColors, sortedColors.length); i++) {
                const [rgbString] = sortedColors[i];
                const [r, g, b] = rgbString.split(',').map(Number);
                extractedColors.push({ r, g, b });
            }

            if (extractedColors.length === 0) {
                paletteDiv.innerHTML = '<p class="text-center w-full text-gray-500 text-sm">Could not extract colors. Try a different image.</p>';
                return;
            }

            extractedColors.forEach(color => {
                const swatch = document.createElement('div');
                const hex = rgbToHex(color.r, color.g, color.b);
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = hex;
                // Determine text color based on background luminance for readability
                const luminance = (0.299 * color.r + 0.587 * color.g + 0.114 * color.b) / 255;
                swatch.style.color = luminance > 0.5 ? '#222222' : '#ffffff'; // Dark text for light background, light text for dark background
                swatch.style.textShadow = luminance > 0.5 ? 'none' : '0 0 1px rgba(0,0,0,0.8)';

                swatch.textContent = hex;
                swatch.title = `Click to copy ${hex}`;
                swatch.onclick = () => {
                    document.execCommand('copy'); // Fallback for clipboard API if not supported or in iframe
                    const textArea = document.createElement('textarea');
                    textArea.value = hex;
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        showMessageBox(`Copied ${hex} to clipboard!`, 'success');
                    } catch (err) {
                        showMessageBox(`Failed to copy ${hex}. Please copy manually: ${hex}`, 'error');
                    }
                    document.body.removeChild(textArea);
                };
                paletteDiv.appendChild(swatch);
            });
        }

        // --- Pixelate Mode Specific Functions ---
        /**
         * Applies a pixelation effect to the image in the Pixelate tab.
         * It achieves this by drawing the image to a very small temporary canvas,
         * and then drawing that small canvas back to the main canvas at a large size, with image smoothing disabled.
         */
        function applyPixelateEffect() {
            const imageToProcess = pixelateLocalImage || sharedImage; // Prioritize local, then shared
            if (!imageToProcess) {
                clearCanvas(pixelateCtx);
                return;
            }

            const pixelSize = parseInt(pixelSizeSlider.value);
            if (pixelSize < 1) { // Ensure pixel size is at least 1
                pixelSizeSlider.value = 1; // Clamp value
                pixelSizeValueSpan.textContent = "1px";
                return;
            }

            // Temporarily resize canvas to original image size for accurate pixelation
            const originalWidth = imageToProcess.width;
            const originalHeight = imageToProcess.height;
            
            pixelateCanvas.width = originalWidth;
            pixelateCanvas.height = originalHeight;
            pixelateCtx.imageSmoothingEnabled = false; // Disable smoothing for crisp pixels

            // Draw image scaled down
            const scaledWidth = originalWidth / pixelSize;
            const scaledHeight = originalHeight / pixelSize;

            // Create a temporary canvas for downscaling
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = scaledWidth;
            tempCanvas.height = scaledHeight;

            tempCtx.drawImage(imageToProcess, 0, 0, scaledWidth, scaledHeight);

            // Draw the pixelated (downscaled and then upscaled) image back to the main pixelateCanvas
            pixelateCtx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, originalWidth, originalHeight);
        }


        // --- Animation Combiner Specific Functions ---

        /**
         * Initializes the Three.js scene for the Animation Combiner tab.
         * This is called only once when the user first tries to load a model.
         */
        function initThreeJsAnimationCombiner() {
            if (isAnimSceneInitialized) return;

            const canvas = animationCombinerThreeJsCanvas;
            const wrapper = canvas.parentElement;

            animScene = new THREE.Scene();
            animScene.background = new THREE.Color(0x2a2a2a);

            animCamera = new THREE.PerspectiveCamera(45, wrapper.clientWidth / wrapper.clientHeight, 0.1, 1000);
            animCamera.position.set(200, 200, 400);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
            hemiLight.position.set(0, 200, 0);
            animScene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 5.5);
            dirLight.position.set(0, 200, 100);
            dirLight.castShadow = true;
            animScene.add(dirLight);
            
            // Ground plane
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshPhongMaterial({ color: 0x555555, depthWrite: false }));
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            animScene.add(ground);

            const grid = new THREE.GridHelper(2000, 20, 0x000000, 0x000000);
            grid.material.opacity = 0.2;
            grid.material.transparent = true;
            animScene.add(grid);

            animRenderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            animRenderer.setPixelRatio(window.devicePixelRatio);
            animRenderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
            animRenderer.shadowMap.enabled = true;

            animControls = new OrbitControls(animCamera, animRenderer.domElement);
            animControls.target.set(0, 100, 0);
            animControls.update();

            // Add a helper to visualize the root bone's position
            const helperGeometry = new THREE.SphereGeometry(5, 8, 8); // 5cm sphere
            const helperMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
            rootBoneHelper = new THREE.Mesh(helperGeometry, helperMaterial);
            rootBoneHelper.visible = false; // Initially hidden
            animScene.add(rootBoneHelper);

            window.addEventListener('resize', () => {
                if (currentActiveTabId === 'animation-combiner-tab') {
                    animCamera.aspect = wrapper.clientWidth / wrapper.clientHeight;
                    animCamera.updateProjectionMatrix();
                    animRenderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
                }
            });

            isAnimSceneInitialized = true;
            animateThreeJsAnimationCombiner();
        }

        /**
         * Smoothly transitions from the previous animation action to the new one.
         * @param {string} actionName The name of the animation to fade to.
         * @param {number} duration The duration of the fade in seconds.
         */
        function fadeToAction(actionName, duration) {
            isRootMotionFirstFrame = true; // Reset root motion state on any animation change.
            previousAction = activeAction;
            activeAction = animationActions.get(actionName);

            if (previousAction !== activeAction) {
                previousAction.fadeOut(duration);
            }

            activeAction
                .reset()
                .setEffectiveWeight(1)
                .fadeIn(duration)
                .play();
        }
        /**
         * The animation loop for the Animation Combiner scene.
         */
        function animateThreeJsAnimationCombiner() {
            requestAnimationFrame(animateThreeJsAnimationCombiner);
            const delta = animClock.getDelta();

            if (animMixer) {
                const enableRootMotion = enableRootMotionCheckbox.checked;
                const rootBone = loadedCharacter ? loadedCharacter.getObjectByName('mixamorig:Hips') : null;

                if (enableRootMotion && rootBone) {
                    // First, update the mixer. This applies the animation transform to the bone's local matrix.
                    animMixer.update(delta);

                    if (isRootMotionFirstFrame) {
                        // On the first frame, capture the bone's initial local transform. This is our "anchor" point.
                        initialRootBonePosition.copy(rootBone.position);
                        initialRootBoneQuaternion.copy(rootBone.quaternion);
                        isRootMotionFirstFrame = false;
                    }

                    // Get the "true" animated world position for the helper before we modify the bone
                    const trueAnimatedWorldPos = new THREE.Vector3();
                    rootBone.getWorldPosition(trueAnimatedWorldPos);

                    // Calculate the difference between the current animated local transform and our initial anchor transform.
                    // This difference is the motion from the animation clip, isolated from the character's world movement.
                    const positionDelta = rootBone.position.clone().sub(initialRootBonePosition);
                    const quaternionDelta = rootBone.quaternion.clone().multiply(initialRootBoneQuaternion.clone().invert());

                    // --- Apply Position Change to the Character ---
                    const motionDelta = positionDelta.clone();
                    motionDelta.y = 0; // We only want ground-plane motion.
                    // The motionDelta is in the character's local space. Rotate it to match the character's world orientation.
                    motionDelta.applyQuaternion(loadedCharacter.quaternion);
                    loadedCharacter.position.add(motionDelta);

                    // --- Apply Rotation Change to the Character ---
                    // We only want rotation around the Y (up) axis.
                    const y_rotation = new THREE.Euler().setFromQuaternion(quaternionDelta, 'YXZ').y;
                    const rotation_quat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), y_rotation);
                    loadedCharacter.quaternion.multiply(rotation_quat);

                    // --- Reset the Bone ---
                    // Now, we must counteract the motion by resetting the root bone back to its initial local transform.
                    // This "pins" the skeleton back to the character's origin, preventing it from walking away.
                    rootBone.position.copy(initialRootBonePosition);
                    rootBone.quaternion.copy(initialRootBoneQuaternion);

                    // Update the helper to show the "ghost" of where the animation is.
                    if (rootBoneHelper) {
                        rootBoneHelper.visible = true;
                        rootBoneHelper.position.copy(trueAnimatedWorldPos);
                    }
                } else {
                    // If root motion is disabled, reset the state for the next time it's enabled.
                    isRootMotionFirstFrame = true;
                    if (rootBoneHelper) rootBoneHelper.visible = false;
                    animMixer.update(delta);
                }
            }

            if (animRenderer) animRenderer.render(animScene, animCamera);
        }

        /**
         * Loads the character and animation FBX files and starts playback.
         */
        async function loadAndPlayAnimations() {
            if (characterFbxInput.files.length === 0 || animationFbxInput.files.length === 0) {
                showMessageBox('Please upload a character FBX and at least one animation FBX.', 'error');
                return;
            }

            initThreeJsAnimationCombiner(); // Ensure scene is ready
            animationPlaceholderText.textContent = 'Loading...';

            // Clear previous character and animations
            if (loadedCharacter) animScene.remove(loadedCharacter);
            animationActions.clear();
            animMixer = null;
            animationSelect.innerHTML = ''; // Clear the dropdown
            isRootMotionFirstFrame = true; // Reset root motion state

            const loader = new FBXLoader();

            try {
                // Load character
                const characterURL = URL.createObjectURL(characterFbxInput.files[0]);
                loadedCharacter = await loader.loadAsync(characterURL);
                loadedCharacter.traverse(child => { if (child.isMesh) child.castShadow = true; });
                animScene.add(loadedCharacter);

                // Create mixer
                animMixer = new THREE.AnimationMixer(loadedCharacter);

                // Load all animation files concurrently
                const animFiles = Array.from(animationFbxInput.files);
                const animPromises = animFiles.map(file => loader.loadAsync(URL.createObjectURL(file)));
                const loadedAnims = await Promise.all(animPromises);

                // Use the file name to create unique animation names
                loadedAnims.forEach((animFbx, fileIndex) => {
                    const file = animFiles[fileIndex];
                    const baseName = file.name.split('.').slice(0, -1).join('.') || file.name;

                    animFbx.animations.forEach(clip => {
                        // Create a unique name to avoid conflicts if clips in different files have the same name (e.g., "mixamo.com")
                        const uniqueName = `${baseName} | ${clip.name}`;
                        clip.name = uniqueName; // Modify the clip's name directly for consistency

                        const action = animMixer.clipAction(clip);
                        action.setEffectiveTimeScale(parseFloat(animationSpeedSlider.value));
                        animationActions.set(uniqueName, action);
                        // Populate the dropdown
                        const option = document.createElement('option');
                        option.value = uniqueName;
                        option.textContent = uniqueName;
                        animationSelect.appendChild(option);
                    });
                });

                if (animationActions.size > 0) {
                    // Play the first animation found
                    activeAction = animationActions.values().next().value; // Get the first action
                    activeAction.play();
                    animationPlaceholderText.textContent = `Playing: ${activeAction.getClip().name}`;
                } else {
                    animationPlaceholderText.textContent = 'Character loaded, but no animations found in the provided files.';
                }

                // Show the canvas
                animationCombinerThreeJsCanvas.style.display = 'block';
                animationPlaceholderText.style.position = 'absolute';
                animationPlaceholderText.style.bottom = '10px';
                animationPlaceholderText.style.left = '10px';
                animationPlaceholderText.style.backgroundColor = 'rgba(0,0,0,0.5)';
                animationPlaceholderText.style.padding = '2px 5px';
                animationPlaceholderText.style.borderRadius = '3px';

            } catch (error) {
                console.error("Error loading FBX files:", error);
                showMessageBox(`Failed to load FBX files. Check console for details. Error: ${error.message}`, 'error');
                animationPlaceholderText.textContent = 'Error loading files. Please check console.';
            }
        }

        /**
         * Updates the speed of the currently playing animation.
         */
        function updateAnimationSpeed() {
            const speed = parseFloat(animationSpeedSlider.value);
            animationSpeedValueSpan.textContent = speed.toFixed(2);
            if (activeAction) {
                activeAction.setEffectiveTimeScale(speed);
            } else {
                // If no action is active yet, apply to all stored actions
                animationActions.forEach(action => action.setEffectiveTimeScale(speed));
            }
        }

        /**
         * Initializes the Three.js scene for the Image to Mesh tab.
         */
        function initThreeJsImageToMesh() {
            if (isMeshSceneInitialized) return;

            // --- Textured Scene Setup (Right Side) ---
            const texturedCanvas = imageToMeshThreeJsCanvas;
            const texturedWrapper = texturedCanvas.parentElement;
            meshScene = new THREE.Scene();
            meshScene.background = new THREE.Color(0x2a2a2a);
            meshCamera = new THREE.PerspectiveCamera(45, texturedWrapper.clientWidth / texturedWrapper.clientHeight, 0.1, 1000);
            meshCamera.position.set(0, 2, 3); // Adjusted for 2m object: (0, 100/50, 150/50)
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
            hemiLight.position.set(0, 200, 0);
            meshScene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(50, 50, 50);
            meshScene.add(dirLight);
            meshRenderer = new THREE.WebGLRenderer({ canvas: texturedCanvas, antialias: true });
            meshRenderer.setPixelRatio(window.devicePixelRatio);
            meshRenderer.setSize(texturedWrapper.clientWidth, texturedWrapper.clientHeight);

            // --- Depth Scene Setup (Left Side) ---
            const depthCanvas = imageToMeshDepthCanvas;
            const depthWrapper = depthCanvas.parentElement;
            meshDepthScene = new THREE.Scene();
            meshDepthScene.background = new THREE.Color(0x1a1a1a); // Slightly different background for distinction
            // Use a tighter near/far range for the depth camera to maximize contrast.
            // The main camera needs a large range for zooming, but this one can be constrained to the object's typical distance.
            meshDepthCamera = new THREE.PerspectiveCamera(45, depthWrapper.clientWidth / depthWrapper.clientHeight, 1, 400);
            meshDepthCamera.position.copy(meshCamera.position); // Start at same position
            meshDepthRenderer = new THREE.WebGLRenderer({ canvas: depthCanvas, antialias: true });
            meshDepthRenderer.setPixelRatio(window.devicePixelRatio);
            meshDepthRenderer.setSize(depthWrapper.clientWidth, depthWrapper.clientHeight);

            // --- Shared Controls ---
            // Controls are attached to the main (textured) renderer's DOM element
            meshControls = new OrbitControls(meshCamera, meshRenderer.domElement);
            meshControls.target.set(0, 0, 0);
            meshControls.update();
            meshControls.saveState(); // Save the initial state for resetting

            window.addEventListener('resize', () => {
                if (currentActiveTabId === 'image-to-mesh-tab') {
                    // Resize textured view
                    if (texturedWrapper.clientWidth > 0) {
                        meshCamera.aspect = texturedWrapper.clientWidth / texturedWrapper.clientHeight;
                        meshCamera.updateProjectionMatrix();
                        meshRenderer.setSize(texturedWrapper.clientWidth, texturedWrapper.clientHeight);
                    }
                    // Resize depth view
                    if (depthWrapper.clientWidth > 0) {
                        meshDepthCamera.aspect = depthWrapper.clientWidth / depthWrapper.clientHeight;
                        meshDepthCamera.updateProjectionMatrix();
                        meshDepthRenderer.setSize(depthWrapper.clientWidth, depthWrapper.clientHeight);
                    }
                }
            });

            isMeshSceneInitialized = true;
            animateThreeJsImageToMesh();
        }
        /**
         * The animation loop for the Image to Mesh scene.
         */
        function animateThreeJsImageToMesh() {
            if (!isMeshSceneInitialized) return;
            requestAnimationFrame(animateThreeJsImageToMesh);
            
            if (meshControls) meshControls.update();

            // Sync the depth camera to the main camera controlled by OrbitControls
            if (meshDepthCamera && meshControls) {
                meshDepthCamera.position.copy(meshCamera.position);
                meshDepthCamera.quaternion.copy(meshCamera.quaternion);
                meshDepthCamera.zoom = meshCamera.zoom;

                // --- DYNAMICALLY ADJUST NEAR/FAR for DEPTH CAMERA --- 
                // This is the key to getting good contrast with MeshDepthMaterial
                // as the user zooms in and out. The depth range is fitted to the object.
                const distance = meshCamera.position.distanceTo(meshControls.target);
                const objectBoundingSphereRadius = 150; // A rough estimate of the object's size/depth

                // Set near and far planes to tightly frame the object based on camera distance
                meshDepthCamera.near = Math.max(0.1, distance - objectBoundingSphereRadius);
                meshDepthCamera.far = distance + objectBoundingSphereRadius;

                meshDepthCamera.updateProjectionMatrix();
            }

            if (meshRenderer) meshRenderer.render(meshScene, meshCamera);
            if (meshDepthRenderer) meshDepthRenderer.render(meshDepthScene, meshDepthCamera);
        }

        /**
         * Generates a Normal Map directly from a displaced geometry's vertex normals.
         * This provides a much more accurate representation of the 3D surface for lighting.
         * @param {THREE.PlaneGeometry} geometry The displaced and smoothed geometry.
         * @param {HTMLCanvasElement} targetCanvas The canvas to draw the new normal map on. Its dimensions will be used for the output.
         * @param {boolean} invertY Whether to invert the Y (green) channel of the normal map.
         */
        function generateNormalMapFromGeometry(geometry, targetCanvas, invertY) {
            if (!geometry || !targetCanvas || !sharedImage) {
                clearCanvas(targetCanvas.getContext('2d'));
                return;
            }

            const geomWidth = geometry.parameters.widthSegments + 1;
            const geomHeight = geometry.parameters.heightSegments + 1;

            // Create a small, temporary canvas matching the geometry's resolution
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = geomWidth;
            tempCanvas.height = geomHeight;
            const tempCtx = tempCanvas.getContext('2d');
            const newImageData = tempCtx.createImageData(geomWidth, geomHeight);
            const newData = newImageData.data;

            const normals = geometry.attributes.normal;
            const normal = new THREE.Vector3();

            for (let j = 0; j < geomHeight; j++) {
                for (let i = 0; i < geomWidth; i++) {
                    // We need to read vertices in the order they are stored in the buffer.
                    // For a PlaneGeometry, this is row by row.
                    const index = j * geomWidth + i;
                    normal.fromBufferAttribute(normals, index);

                    // Convert normal vector (-1 to 1) to RGB color (0 to 255)
                    const r = (normal.x * 0.5 + 0.5) * 255;
                    let g = (normal.y * 0.5 + 0.5) * 255;
                    const b = (normal.z * 0.5 + 0.5) * 255;

                    if (invertY) {
                        g = ((-normal.y * 0.5) + 0.5) * 255;
                    }

                    const pixelIndex = (j * geomWidth + i) * 4;
                    newData[pixelIndex] = r;
                    newData[pixelIndex + 1] = g;
                    newData[pixelIndex + 2] = b;
                    newData[pixelIndex + 3] = 255;
                }
            }
            tempCtx.putImageData(newImageData, 0, 0);

            // Now, draw the low-resolution temp canvas onto the high-resolution target canvas
            // with smoothing enabled to interpolate the normals.
            const targetCtx = targetCanvas.getContext('2d');
            targetCanvas.width = sharedImage.width; // Match original texture size
            targetCanvas.height = sharedImage.height;
            targetCtx.imageSmoothingEnabled = true;
            targetCtx.imageSmoothingQuality = 'high';
            targetCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
            targetCtx.drawImage(tempCanvas, 0, 0, targetCanvas.width, targetCanvas.height);
        }

        /**
         * Applies Taubin smoothing to a plane geometry's vertices to reduce noise while preserving volume.
         * It alternates between a "shrink" step (positive lambda) and a "grow" step (negative mu).
         * @param {THREE.PlaneGeometry} geometry The geometry to smooth.
         * @param {number} iterations The number of smoothing passes.
         * @param {number} lambda The shrinking factor (e.g., 0.5).
         * @param {number} mu The growing factor (e.g., -0.53). A negative value slightly larger in magnitude than lambda.
         */
        function taubinSmoothMesh(geometry, iterations, lambda = 0.5, mu = -0.53) {
            const positions = geometry.attributes.position;
            const vertexCount = positions.count;
            const widthSegments = geometry.parameters.widthSegments;
            const heightSegments = geometry.parameters.heightSegments;
            const gridWidth = widthSegments + 1;

            // A temporary array to read from during each iteration, so we don't modify the array we're reading from.
            let tempZ = new Float32Array(vertexCount);

            for (let iter = 0; iter < iterations; iter++) {
                // --- Shrink Step (lambda) ---
                // Copy current Z positions for reading
                for (let i = 0; i < vertexCount; i++) { tempZ[i] = positions.getZ(i); }

                // Apply shrink to all interior vertices
                for (let j = 1; j < heightSegments; j++) {
                    for (let i = 1; i < widthSegments; i++) {
                        const index = j * gridWidth + i;
                        const top = tempZ[index - gridWidth];
                        const bottom = tempZ[index + gridWidth];
                        const left = tempZ[index - 1];
                        const right = tempZ[index + 1];
                        const averageZ = (top + bottom + left + right) / 4.0;
                        const newZ = tempZ[index] + lambda * (averageZ - tempZ[index]);
                        positions.setZ(index, newZ);
                    }
                }

                // --- Grow Step (mu) ---
                // Copy shrunk Z positions for reading
                for (let i = 0; i < vertexCount; i++) { tempZ[i] = positions.getZ(i); }

                // Apply grow to all interior vertices
                for (let j = 1; j < heightSegments; j++) {
                    for (let i = 1; i < widthSegments; i++) {
                        const index = j * gridWidth + i;
                        const top = tempZ[index - gridWidth];
                        const bottom = tempZ[index + gridWidth];
                        const left = tempZ[index - 1];
                        const right = tempZ[index + 1];
                        const averageZ = (top + bottom + left + right) / 4.0;
                        const newZ = tempZ[index] + mu * (averageZ - tempZ[index]);
                        positions.setZ(index, newZ);
                    }
                }
            }
        }

        /**
         * Generates a 3D displaced plane mesh from an image.
         */
        function generateMeshFromImage() {
            const imageToProcess = meshLocalImage || sharedImage;
            if (!imageToProcess) {
                // Hide canvases and show placeholders
                meshPlaceholderText.style.display = 'block';
                meshDepthPlaceholderText.style.display = 'block';
                imageToMeshThreeJsCanvas.style.display = 'none';
                imageToMeshDepthCanvas.style.display = 'none';

                // Clean up textured mesh
                if (generatedMesh) {
                    meshScene.remove(generatedMesh);
                    generatedMesh.geometry.dispose();
                    generatedMesh.material.dispose();
                    generatedMesh = null;
                }
                // Clean up depth mesh
                if (generatedDepthMesh) {
                    meshDepthScene.remove(generatedDepthMesh);
                    // Geometry is shared, so don't dispose it twice
                    generatedDepthMesh.material.dispose();
                    generatedDepthMesh = null;
                }
                return;
            }

            initThreeJsImageToMesh(); // Ensure scene is ready
            // Show canvases and hide placeholders
            meshPlaceholderText.style.display = 'none';
            meshDepthPlaceholderText.style.display = 'none';
            imageToMeshThreeJsCanvas.style.display = 'block';
            imageToMeshDepthCanvas.style.display = 'block';

            // Get parameters from sliders
            const detail = parseInt(meshDetailSlider.value);
            const heightScale = parseFloat(meshHeightSlider.value); // Value from 0 to 200
            const heightMultiplier = 0.01; // Scale factor to make 2 units = 2cm, 200 units = 2m

            // Create a temporary canvas for heightmap processing
            const heightmapCanvas = document.createElement('canvas');
            const heightmapCtx = heightmapCanvas.getContext('2d');
            heightmapCanvas.width = imageToProcess.width;
            heightmapCanvas.height = imageToProcess.height;

            heightmapCtx.drawImage(imageToProcess, 0, 0);
            const imageData = heightmapCtx.getImageData(0, 0, heightmapCanvas.width, heightmapCanvas.height);
            const heightmapData = imageData.data;

            // Remove old meshes if they exist
            if (generatedMesh) {
                meshScene.remove(generatedMesh);
                generatedMesh.geometry.dispose();
                generatedMesh.material.dispose();
            }
            if (generatedDepthMesh) {
                meshDepthScene.remove(generatedDepthMesh);
                // Geometry is shared, material is unique
                generatedDepthMesh.material.dispose();
            }

            const planeSize = 2; // A fixed size for the mesh in the 3D scene (2 meters)
            
            let planeWidth = planeSize;
            let planeHeight = planeSize;

            const imageAspectRatio = imageToProcess.width / imageToProcess.height;
            if (imageAspectRatio > 1) { // Image is wider than it is tall
                planeHeight = planeSize / imageAspectRatio;
            } else if (imageAspectRatio < 1) { // Image is taller than it is wide
                planeWidth = planeSize * imageAspectRatio;
            }
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight, detail, detail);
            const positions = geometry.attributes.position;

            const imgWidth = imageData.width;
            const imgHeight = imageData.height;

            for (let i = 0; i < positions.count; i++) {
                // Map vertex position (-planeSize/2 to +planeSize/2) to UV coordinates (0 to 1)
                const u = (positions.getX(i) / planeWidth) + 0.5;
                const v = 1.0 - ((positions.getY(i) / planeHeight) + 0.5); // Flip V for image coords

                const tx = Math.floor(u * (imgWidth - 1));
                const ty = Math.floor(v * (imgHeight - 1));
                const pixelIndex = (ty * imgWidth + tx) * 4;

                // Get grayscale value (0-1) from the red channel of the heightmap
                const grayscale = toGrayscale(heightmapData[pixelIndex], heightmapData[pixelIndex + 1], heightmapData[pixelIndex + 2]) / 255.0;

                // Displace the vertex along the Z axis
                positions.setZ(i, grayscale * heightScale * heightMultiplier); // Apply the new multiplier
            }

            positions.needsUpdate = true;

            // --- NEW: Apply Smoothing ---
            if (smoothMeshCheckbox.checked) {
                const iterations = parseInt(meshSmoothingIterationsSlider.value);
                taubinSmoothMesh(geometry, iterations); // A lambda of 0.5 is a good starting point.
            }
            geometry.computeVertexNormals(); // Crucial for correct lighting after displacement and smoothing

            // --- NEW: Automatically update the PBR Normal Map based on this geometry ---
            if (sharedImage) { // Only if there's a base image to define resolution and be textured
                generateNormalMapFromGeometry(geometry, fullResNormalCanvas, invertNormalYCheckbox.checked);
                updatePreviewCanvases(); // Update the 2D preview in the PBR tab
                updateThreeJsTextures(); // Update the main PBR 3D viewer
            }

            const texturedMaterial = new THREE.MeshStandardMaterial({
                side: THREE.DoubleSide
            });

            generatedMesh = new THREE.Mesh(geometry, texturedMaterial);
            generatedMesh.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            meshScene.add(generatedMesh);

            // Sync with the PBR material state.
            syncMeshMaterialFromPbr();

            // Fallback: If sync didn't apply a map (e.g., no PBR image loaded), use the base image.
            if (!texturedMaterial.map && imageToProcess) {
                const texture = new THREE.Texture(imageToProcess);
                texture.needsUpdate = true;
                texture.encoding = THREE.sRGBEncoding;
                texturedMaterial.map = texture;
                texturedMaterial.roughness = 0.8;
                texturedMaterial.metalness = 0.2;
            }
            texturedMaterial.needsUpdate = true;

            // --- Create Left Preview Mesh based on selected mode ---
            let leftPreviewMaterial;
            const previewMode = meshPreviewModeSelect.value;

            if (previewMode === 'depth') {
                leftPreviewMaterial = new THREE.MeshDepthMaterial({
                    side: THREE.DoubleSide,
                    depthPacking: THREE.RGBADepthPacking
                });
            } else if (previewMode === 'normal') {
                leftPreviewMaterial = new THREE.MeshNormalMaterial({
                    side: THREE.DoubleSide
                });
            } else if (previewMode === 'wireframe') {
                leftPreviewMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00, // A clear green for wireframe
                    wireframe: true,
                    side: THREE.DoubleSide
                });
            }
            
            generatedDepthMesh = new THREE.Mesh(geometry, leftPreviewMaterial); // Use the SAME geometry
            generatedDepthMesh.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            meshDepthScene.add(generatedDepthMesh);
        }
        // --- Tab Switching Logic ---

        /**
         * Shows the selected tab and hides others.
         * Manages the 'active' class on buttons and content panes, and also shows/hides
         * the correct control panels in the left-hand sidebar.
         * @param {string} tabId - The ID of the tab content to show.
         */
        function showTab(tabId) {
            currentActiveTabId = tabId; // Update active tab ID

            // Deactivate all tab buttons and hide all tab content
            document.querySelectorAll('.tab-button').forEach(button => button.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            // Hide all control groups that are direct children of the left panel
            document.querySelectorAll('.left-panel > .controls-group').forEach(controls => controls.style.display = 'none');
            // Hide the right-side controls container by default unless it's the texture weaver tab
            document.querySelector('.right-side-controls-container').style.display = 'none';

            // --- UI State Management for the selected tab ---
            // Activate the clicked tab button
            document.querySelector(`.tab-button[data-tab-id="${tabId}"]`).classList.add('active');
            
            // Show the corresponding tab content and controls
            document.getElementById(tabId).classList.add('active');
            
            // Manage cursor for threeJsCanvas based on tab. 
            if (tabId === 'texture-pbr-tab') { // PBR Tab
                threeJsCanvas.style.cursor = 'grab';
                document.getElementById('threeJsCanvas').style.display = 'block';
            } else {
                threeJsCanvas.style.cursor = 'default';
                // largePreviewCanvasContainer.classList.remove('active'); // Removed
                document.getElementById('threeJsCanvas').style.display = 'none'; // Hide main 3D canvas temporarily
            }
            
            // Show specific controls/canvases based on tab.
            if (tabId === 'color-extractor-tab') { // Colors Tab
                colorExtractorControls.style.display = 'flex';
                colorExtractorCanvas.style.display = 'block';
            } else if (tabId === 'pixelate-tab') {
                pixelateControls.style.display = 'flex';
                pixelateCanvas.style.display = 'block';
            } else if (tabId === 'animation-combiner-tab') {
                animationCombinerControls.style.display = 'flex';
                // animationCombinerThreeJsCanvas.style.display = 'block'; // Keep conceptual for now
            } else if (tabId === 'image-to-mesh-tab') {
                imageToMeshControls.style.display = 'flex';
                if (isMeshSceneInitialized) {
                    imageToMeshThreeJsCanvas.style.display = 'block';
                    imageToMeshDepthCanvas.style.display = 'block';
                    // Trigger a resize event to ensure canvases have correct dimensions
                    window.dispatchEvent(new Event('resize'));
                }
            } else if (tabId === 'texture-pbr-tab') {
                textureWeaverControls.style.display = 'flex'; // Show left-panel controls
                // When switching back to PBR tab, resize its renderer
                if (renderer) {
                    camera.aspect = threeJsCanvas.clientWidth / threeJsCanvas.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(threeJsCanvas.clientWidth, threeJsCanvas.clientHeight);
                }
                // Also show the newly moved controls on the right side
                document.querySelector('.right-side-controls-container').style.display = 'flex';
            }

            // Ensure descriptive text is visible for current tab
            document.querySelectorAll('.tab-content h1, .tab-content p').forEach(el => {
                 if (el) el.style.display = 'block'; // Show all h1 and p in tab-content initially
            });

            applyEffectToCurrentTab(); // Trigger an update for the newly active tab
        }

        // Removed showLargeMapPreview and hideLargeMapPreview functions


        // --- Initial Setup (runs after DOM is parsed, due to type="module" placement) ---
        console.log("Initializing 3D Artist Toolbox...");
        clearAllCanvases(); // Clear 2D canvases initially and draw fallback text

        // Initialize Three.js after DOM elements are available
        initThreeJsTextureWeaver(threeJsCanvas, textureWeaverTab);
        updateThreeJsTextures(); // Initial texture update for weaver (with empty textures)
        updateSunPosition(); // Set initial sun position
        
        // Attach Event Listeners for Tab Buttons
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.getAttribute('data-tab-id');
                if (tabId) {
                    showTab(tabId);
                }
            });
        });

        // Attach Event Listeners - IMAGE UPLOADS
        textureInput.addEventListener('change', (e) => loadImageAndSetShared(e.target.files[0], loadingSpinner, textureInput));
        colorImageInput.addEventListener('change', (e) => loadImageAndSetShared(e.target.files[0], colorLoadingSpinner, colorImageInput));
        makeSeamlessButton.addEventListener('click', makeSourceTextureSeamless);
        pixelateImageInput.addEventListener('change', (e) => loadImageAndSetShared(e.target.files[0], pixelateLoadingSpinner, pixelateImageInput));
        meshImageInput.addEventListener('change', (e) => loadImageAndSetShared(e.target.files[0], meshLoadingSpinner, meshImageInput));


        // Attach Event Listeners - TEXTURE WEAVER CONTROLS (3D Material Properties)
        invertNormalYCheckbox.addEventListener('change', () => {
            if (sharedImage) {
                generateMaps(); // Regenerate all maps to reflect the change
            }
        });
        invertMetallicCheckbox.addEventListener('change', () => {
            if (sharedImage) {
                generateMaps(); // Regenerate all maps to reflect the change
            }
        });
        normalStrengthSlider.addEventListener('input', () => {
            normalStrengthValueSpan.textContent = parseFloat(normalStrengthSlider.value).toFixed(2);
            updateThreeJsTextures(); // Apply directly to 3D material
        });
        aoIntensitySlider.addEventListener('input', () => {
            aoIntensityValueSpan.textContent = parseFloat(aoIntensitySlider.value).toFixed(2);
            updateThreeJsTextures(); // Apply directly to 3D material
        });
        displacementScaleSlider.addEventListener('input', () => {
            displacementScaleValueSpan.textContent = parseFloat(displacementScaleSlider.value).toFixed(2);
            updateThreeJsTextures();
        });
        displacementBiasSlider.addEventListener('input', () => {
            displacementBiasValueSpan.textContent = parseFloat(displacementBiasSlider.value).toFixed(2);
            updateThreeJsTextures();
        });

        // Attach Event Listeners - 2D Map Generation Adjustments
        roughnessIntensitySlider.addEventListener('input', () => {
            roughnessIntensityValueSpan.textContent = parseFloat(roughnessIntensitySlider.value).toFixed(2);
            if (sharedImage) {
                generateMaps(); // Regenerate all maps to reflect the change
            }
        });
        aoContrastSlider.addEventListener('input', () => {
            aoContrastValueSpan.textContent = parseFloat(aoContrastSlider.value).toFixed(2);
            if (sharedImage) {
                generateMaps(); // Regenerate all maps to reflect the change
            }
        });
        metallicSharpnessSlider.addEventListener('input', () => {
            metallicSharpnessValueSpan.textContent = parseFloat(metallicSharpnessSlider.value).toFixed(2);
            if (sharedImage) {
                generateMaps(); // Regenerate all maps to reflect the change
            }
        });
        displacementDetailSlider.addEventListener('input', () => {
            displacementDetailValueSpan.textContent = parseFloat(displacementDetailSlider.value).toFixed(2);
            if (sharedImage) {
                generateMaps(); // Regenerate all maps to reflect the change
            }
        });

        // Attach Event Listeners - LIGHTING CONTROLS
        sunAzimuthSlider.addEventListener('input', updateSunPosition);
        sunElevationSlider.addEventListener('input', updateSunPosition);
        sunIntensitySlider.addEventListener('input', updateSunPosition);

        exportButton.addEventListener('click', exportAllMaps);

        // Removed Event Listeners for 2D Map Hover Preview
        // document.querySelectorAll('.map-grid .canvas-container').forEach(container => {
        //     const mapType = container.getAttribute('data-map-type');
        //     const sourceCanvasId = container.getAttribute('data-source-canvas-id');
        //     const sourceCanvas = document.getElementById(sourceCanvasId);

        //     if (sourceCanvas) {
        //         container.addEventListener('mouseover', () => {
        //             if (sharedImage) { // Only show preview if an image is loaded
        //                 showLargeMapPreview(sourceCanvas, mapType);
        //             }
        //         });
        //         container.addEventListener('mouseout', hideLargeMapPreview);
        //     }
        // });

        console.log("Attaching event listeners...");

        // Attach Event Listeners - COLOR EXTRACTOR CONTROLS
        numColorsSlider.addEventListener('input', () => {
            numColorsValueSpan.textContent = numColorsSlider.value;
            // When the slider changes, re-run the palette extraction if an image is available.
            const imageToProcess = colorExtractorLocalImage || sharedImage;
            if (imageToProcess) {
                extractColorPalette(imageToProcess);
            }
        });

        // Attach Event Listeners - PIXELATE MODE CONTROLS
        pixelSizeSlider.addEventListener('input', () => {
            pixelSizeValueSpan.textContent = pixelSizeSlider.value + "px";
            applyPixelateEffect(); // Call effect on slider change
        });


        // Attach Event Listeners - ANIMATION COMBINER CONTROLS
        characterFbxInput.addEventListener('change', updateAllFileDisplays);
        animationFbxInput.addEventListener('change', updateAllFileDisplays);
        animationSelect.addEventListener('change', (e) => {
            if (activeAction && animationActions.has(e.target.value)) {
                fadeToAction(e.target.value, 0.3);
                animationPlaceholderText.textContent = `Playing: ${e.target.value}`;
            }
        });
        animationSpeedSlider.addEventListener('input', updateAnimationSpeed);
        loadAndPlayAnimationsButton.addEventListener('click', loadAndPlayAnimations);

        // Attach Event Listeners - IMAGE TO MESH CONTROLS
        meshDetailSlider.addEventListener('input', () => {
            meshDetailValue.textContent = meshDetailSlider.value;
            generateMeshFromImage();
        });
        meshHeightSlider.addEventListener('input', () => {
            meshHeightValue.textContent = meshHeightSlider.value;
            generateMeshFromImage();
        });
        smoothMeshCheckbox.addEventListener('change', () => {
            meshSmoothingControls.style.display = smoothMeshCheckbox.checked ? 'flex' : 'none';
            generateMeshFromImage();
        });
        meshSmoothingIterationsSlider.addEventListener('input', () => {
            meshSmoothingIterationsValue.textContent = meshSmoothingIterationsSlider.value;
            generateMeshFromImage();
        });
        meshPreviewModeSelect.addEventListener('change', generateMeshFromImage);

        exportGlbButton.addEventListener('click', () => exportMeshAsGlb(generatedMesh));

        // Attach Event Listeners - CAMERA RESET BUTTONS
        resetPbrCameraBtn.addEventListener('click', resetPbrCamera);
        resetMeshCameraBtn.addEventListener('click', resetImageToMeshCamera);

        /**
         * Exports the generated 3D mesh as a GLB file.
         * @param {THREE.Mesh} mesh - The mesh to export.
         */
        async function exportMeshAsGlb(mesh) {
            if (!mesh || !mesh.geometry || !mesh.material) {
                showMessageBox('No mesh has been generated to export.', 'error');
                return;
            }
 
            // Ensure GLTFExporter is loaded
            if (typeof THREE.GLTFExporter === 'undefined') {
                showMessageBox('GLTFExporter is not loaded. Please check script imports.', 'error');
                return;
            }
 
            const exporter = new THREE.GLTFExporter();
            const options = {
                binary: true, // Export as GLB
                embedImages: true, // Embed textures directly into the GLB
            };
 
            const onError = (error) => {
                console.error('An error happened during GLB export:', error);
                showMessageBox('Failed to export GLB file. Check console for details.', 'error');
            };
 
            const onCompleted = (result) => {
                if (!(result instanceof ArrayBuffer)) {
                    onError('Exporter did not return a valid binary ArrayBuffer.');
                    return;
                }
                const blob = new Blob([result], { type: 'application/octet-stream' });
                const baseFileName = (sharedFileName.split('.').slice(0, -1).join('.') || 'generated_mesh');
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `${baseFileName}.glb`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
                showMessageBox('Mesh exported as .GLB file.', 'success');
            };
 
            // For three.js r128, the signature is parse(input, onCompleted, options).
            // The onError callback is part of the options object.
            exporter.parse(mesh, onCompleted, { ...options, onError });
        }

        // Attach Event Listener for all slider reset buttons
        document.querySelectorAll('.reset-slider-button').forEach(button => {
            button.addEventListener('click', (event) => {
                event.preventDefault(); // Prevent form submission if it's ever in a form
                const sliderId = button.dataset.sliderId;
                const slider = document.getElementById(sliderId);
                if (slider) {
                    const defaultValue = slider.getAttribute('value');
                    slider.value = defaultValue;
                    // Dispatch the input event to trigger all associated updates
                    slider.dispatchEvent(new Event('input', { bubbles: true }));
                }
            });
        });

        // Setup all drop zones
        console.log("Setting up drop zones...");
        setupDropZone(textureDropZone, textureInput);
        setupDropZone(colorDropZone, colorImageInput);
        setupDropZone(pixelateDropZone, pixelateImageInput);
        setupDropZone(meshDropZone, meshImageInput);
        // Show the default tab on initial load

        // Attach Event Listeners - SEAMLESS CONTROLS
        seamlessMethodSelect.addEventListener('change', () => {
            seamlessBlendControls.style.display = seamlessMethodSelect.value === 'blend' ? 'block' : 'none';
        });
        seamlessRadiusSlider.addEventListener('input', () => {
            seamlessRadiusValue.textContent = seamlessRadiusSlider.value;
        });
        seamlessIntensitySlider.addEventListener('input', () => {
            seamlessIntensityValue.textContent = seamlessIntensitySlider.value;
        });

        // Attach Event Listeners for Map Preview Clicks
        document.querySelectorAll('.map-grid .canvas-container').forEach(container => {
            // Listener for clicking to isolate the map in the 3D view
            container.addEventListener('click', () => {
                const mapType = container.dataset.mapType;
                set3DPreviewMode(mapType);
            });

            // Add hover listeners for explanations
            const explanation = container.dataset.explanation;
            if (explanation) {
                container.addEventListener('mouseover', () => {
                    mapTooltip.textContent = explanation;
                    mapTooltip.style.display = 'block';
                });
                container.addEventListener('mousemove', (event) => {
                    // Position the tooltip near the cursor, with an offset
                    // Add logic to prevent it from going off-screen
                    const tooltipRect = mapTooltip.getBoundingClientRect();
                    let x = event.clientX + 15;
                    let y = event.clientY + 15;

                    if (x + tooltipRect.width > window.innerWidth) {
                        x = event.clientX - tooltipRect.width - 15;
                    }
                    if (y + tooltipRect.height > window.innerHeight) {
                        y = event.clientY - tooltipRect.height - 15;
                    }

                    mapTooltip.style.left = `${x}px`;
                    mapTooltip.style.top = `${y}px`;
                });
                container.addEventListener('mouseout', () => {
                    mapTooltip.style.display = 'none';
                });
            }
        });


        // Show the default tab on initial load
        showTab('texture-pbr-tab');
        /* showTab('color-extractor-tab'); */
        updateAllFileDisplays(); // Initial update of file name displays
        console.log("Initialization complete.");
    </script>
</body>
</html>